# 1.html

## 1.head 标签 

 <head>用于为页面定义全局信息；所有其他头元素的容器；紧跟在其实元素html的后面；

可包含：title，meta，script，style，link等

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <!--
    name 把 content 属性关联到一个名称。
    （author创作者，description描述了该文档，
    keywords搜索引擎的索引，generator，
    revised编辑软件，others）

    http-equiv 把 content 属性关联到 HTTP 头部。
    （content-type，expires，refresh重定向到新的地址，set-cookie）

    name="keywords" 定义了一组关键字
    content="html,css"  关键词的内容，用于被搜索引擎去搜索使用

    name="description" 定义了网页的描述
    content="html学习使用"  关键词的内容，用于被搜索引擎去搜索使用
    -->
    <meta charset="UTF-8">
    <meta name="keywords" content="html,css">
    <meta name="description" content="前端学习网">
    <!-- 5s后更新重定向到xxx -->
    <meta http-equiv="refresh" content="5;url=http://baidu.com">
    <!-- 标题 -->
    <title>HTML 文档</title>
    <!-- js脚本 -->
    <script type="javascript"></script>
    <!-- css样式 -->
    <style type="text/css"></style>
    <!--css文件链接-->
    <link rel="stylesheet" href="">
</head>
<body>
</body>
</html>

```



## 2.body标签

1.br强制换行
2.nobr强制不换行
3.h1-h6--6级标题
4.p段落
4.1.pre预格式化标记--使网页中显示文本内容和代码中的保持一致
5.div块分区（区域）--会换行
6.span行分区--不会换行
7.块元素(h1,p,div)和行内元素(span)
8.b/strong加粗
9.i/em斜体
10.u下划线
11.s删除线
12.转义字符
13.属性align=”center”文本居中，title属性定义属性的说明文字
13.1.bgcolor网页背景颜色、text文本颜色，background背景图
14.style样式
15.hr分割线（width，size，color）

 

## 3.img 图像

img图像--（src，width，height）--支持jpg、gif、png格式



## 4.a链接

a链接：实现网页的跳转--（href="#"，target="_blank"或者"_self"）
锚点（页面内跳转）

```html
<p id="song">这是一首歌</p>

<a href="#song">跳转到歌</a>
```



## 5.table表格

table表格-tr行-td列

table表格属性：
border="1" 边框宽度  bordercolor边框颜色,align文字水平对齐的方式
width,height,bgcolor背景色,
cellpadding内边距（单元格边框和内容之间的距离）
cellspacing外边距（单元格之间的距离）
background背景设置

```html
<table border="1px" width="600px" height="400px" 
       cellspacing="10px" cellpadding="20px"
       align="center" bgcolor="red" background="image/page.jpg">
    <!-- 默认清空下，背景图会自动平铺重复 -->
</table>
```

tr行属性：
height
align文字水平对齐的方式（left，center，right）
valign文字垂直对齐的方式（top、middle、bottom）

td列属性：
width，height，align文字水平对齐的方式（left，center，right）valign文字垂直对齐的方式（top、middle、bottom）
colspan设置单元格跨列（默认向右跨列），
rowspan设置单元格跨行（默认向下跨行）
只有td中可以嵌套table，实现表中表
th列属性：（文字自动水平垂直居中并且加粗）
表格分组：thead表头，tbody表主体，tfoot表底部
thead，tfoot高度会变小，rowspan跨行不可以跨组



## 6.ol、ul列表

有序列表 ol-li，ul-li无序列表

属性：

type类型：i数字 disk实心圆 circle空心圆 A字母

start：从第几位开始

列表可以嵌套：ol-li-ul-li

定义列表：dl-dt，dd

```html
<dl>
    <dt>定义列表</dt>
    <dd>定义列表是列表的一种，用来制作类似名词解释的内容！</dd>
</dl>
```



## 7.html结构便签，h5新增（header、nav等）

1.header页头部分

2.nav导航部分

3.aside侧边栏部分

4.section页面主体部分

5.footer页脚部分

<img src="C:\Users\Administrator\Desktop\图片1.png" alt="图片1" style="zoom:75%;" />



## 8.form表单元素

### form表单用于显示收集信息并且提交到服务器

#### 1.form元素创建表单

属性：
action：数据提交的url地址
method：数据提交的方式post，get
enctype：表单数据进行编码的方式
name：表单的名称

```html
<form name="form1" method="post" action="data/user.jsp"/>
```



### 表单控件

#### 1.input

属性:
type:text默认文本框
value：文本初始值
size：文本框的宽度 size="40" 就是宽40px
maxlenght：文本框最大字符数
required：必填，disabled：禁用，name：命名，readonly只读，
type:password密码框
type:submit提交按钮，value：按钮名称
type:reset重置按钮，value：按钮名称
type:button普通按钮，value：按钮名称
type:image图片按钮，src图片地址
type：file文件上传
input：hidden隐藏域
type:radio单选，checkbox多选，name：组名，value：选项的名称，checked：默认选中

```html
<input type="radio" name="sex" value="man" checked>男</input>
<input type="radio" name="sex" value="woman">女</input>
<!-- 
	单选框type为radio，必填属性name组名，
	value选项值
-->
```

```html
<input type="checkbox" name="like" value="music" checked>音乐</input>
<input type="checkbox" name="like" value="art">美术</input>
<input type="checkbox" name="like" value="sport">运动</input>
<!-- 
	多选框type为checkbox，必填属性name组名，
	value选项值
-->
```



#### 2.select-option下拉框

属性：
select-multiple 多选，select-size菜单行数，默认一行
option-selected 默认选中

```html
<select name="city" size="5" multiple>
    <option>请选择意向城市</option>
    <option>北京</option>
    <option>南京</option>
    <option>天津</option>
</select>
```



#### 3.textarea文本域

属性：
name名称，cols文本域的列数，rows文本域的行数，readonly只读



#### 4.label标签

属性：
for="#id"，表示和该元素相关联的表单控件的id，然后点击该label文本就相当于点击控件一样



#### 5.控件分组

fieldset控件分组，legend分组标题

```html
<fieldset>
    <legend>地址信息</legend>
    地址：<input type="text"><br/>
    邮编：<input type="text">
</fieldset>
```



## 9.iframe浮动框架

iframe浮动框架--在一个网页中插入其他网页，可以在一个页面中显示多个页面文档
属性：
src：指向其他页面的url
height，width
name：名称
frameborder：边框
scrollering：滚动条 no

```html
<iframe src="1.html" width="600px" height="400px" frameborder="0" name="window" 
        scrolling="no">
</iframe>
```



## 10.摘要summary，细节details--将网页信息进行展开和收缩

details-summary标题

```html
<details>
    <summary>发票信息</summary>
    <div>
    	内容
    </div>
</details>
```



## 11.meter度量元素

属性：min，max，value，title

```html
磁盘空间：<meter min="0" max="100" value="60"></meter>
```



## 12.time时间元素

属性datetime

```html
<time datetime="2011-7-11T0:35">凌晨0点35分</time>
```



## 13.mark高亮文本

```html
<mark>文本高亮</mark>
```





# 2.html5

## 1.简介

html5：是html目前的最新标准，以后不会再更新新的html版本了

新特性：

form新表单

video视频处理

audio音频处理

canvas画布

svg矢量图

geoloaction地理定位和拖拽API

web worker

web存储和web socket



## 2.表单控件-input新类型

input新类型：
email类型 -- 验证是否包含@
url类型 -- 验证是否包含http://
tel电话类型 -- 只在移动端显示
number数字类型
range范围类型
date日期类型 week日期周类型  month日期月份类型
color颜色类型

### 1.email类型:只能输入email地址的文本框 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200718171918202.png" alt="image-20200718171918202" style="zoom:50%;" />

### 2.search类型：输入搜索关键字操作的文本框 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200718171948048.png" alt="image-20200718171948048" style="zoom:50%;" />

### 3.url类型：输入web站点地址的文本框 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200718172007915.png" alt="image-20200718172007915" style="zoom:50%;" />

### 4.tel类型：电话号码类型，主要针对电话号码的输入，能够指示浏览器根据不同的设备进行调整 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200718172032047.png" alt="image-20200718172032047" style="zoom:50%;" />

### 5.number数字类型：只能接受数值 

属性：min最小值，max最大值，step步长

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200718172052123.png" alt="image-20200718172052123" style="zoom:50%;" />

### 6.range范围类型

```html
<input type="range" min="10" max="4000" value="50">
```

属性：min范围下限，max范围上限，step步长，value初始值

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200718172210438.png" alt="image-20200718172210438" style="zoom:50%;" />

### 7.color颜色类型：颜色拾取控件 

```html
<input type="color">
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200718172248065.png" alt="image-20200718172248065" style="zoom:50%;" />

### 8.date日期类型

```html
<input type="date"/>
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200718172329954.png" alt="image-20200718172329954" style="zoom:50%;" />

### 9.week周类型

```html
<input type="week"/>
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200718172421239.png" alt="image-20200718172421239" style="zoom:50%;" />

### 10.month月类型

```html
<input type="month"/>
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200718172654719.png" alt="image-20200718172654719" style="zoom:50%;" />



## 3.表单控件-表单新元素

表单新元素：

datalist：列表元素；

process：进度条元素；

meter：刻度元素；

output：输出元素，了解即可；

### 1.datalist列表元素

是一个表单特有的元素，可以通过list属性预创建一组表单项，后面可以为输入框的输入提示；
需要配置input元素使用

```html
<datalist id='mylist'>
    <option>请选择</option>
    <option>北京</option>
    <option>南京</option>
    <option>天津</option>
</datalist>
<input type="text" list="mylist"/>
```

### 2.process进度条元素

表示一个任务的完成进度，而且这些任务都在表单中启动和处理；

属性：value 任务当前进度，max进度条的最大值；最小值默认为0

```html
<process max="100" value="30"></process>
```

### 3.meter刻度元素

属性：min和max 设置范围的边界，value 确定测量的值，low低预警值、high高预警值、opimum将范围划分成不同的部分和设置最佳位置

```html
<meter min="0" max="100" value="95" low="10" high="90"></meter>
```

### 4.output输出元素

通常显示表单元素处理的结果集（了解即可）

```html
<input id="a"> + <input id="b"> = <input for="a+b">
```



## 4.表单控件-表单新属性

表单新属性

placeholder 默认显示的内容

multiple 允许输入多个值,email,file等类型，插入的值默认使用,逗号隔开

autofocus 自动获取焦点

form 允许表单元素定义在表单之外

### 1.placeholder属性：

文本提示

```html
<input type="text" placeholder="请输入用户名称"/>
```

### 2.multiple属性：

允许输入多个值

```html
<input type="email" multiple>
```

### 3.autofocus属性：

自动获取焦点，相当于js中的focus()方法，适用于所有的input元素

```html
<input type="text" autofocus>
```

### 4.form属性：

是一个实用的附件功能，可以在form标签外面声明表单元素

```html
<form id="myForm"> xxx-form-item  </form>
<input type="text" form="myForm" name="username">
```



## 5.表单控件-表单新验证

表单新验证：

required 表单内容不允许为空

pattern 定义表单的正则表达式

min，max和step 用于包含数字或日期类表单的最小最大约束

minlength、maxlength 验证字符串的长度

validity 代表表单元素的有效状态

### 1.required 属性

防止为空的时候提交表单

```html
<input type="text" required>
```

### 2.pattern 属性

定义表单的正则验证表达式，注意：并不能验证当前元素是否为空（加required）

```html
<input type="text" pattern="13[0-9]\d{8}">
```

### 3.min、max和step属性

适用于date pickers、number和range等包含数字或者日期的类型

```html
<input tepe="number" min="1" max="5">
```

### 4.minlength和maxlength验证字符串的长短

```html
<input tepe="text" minlength="1" maxlength="5">
```

### 5.validity属性

该属性使用ValidityState对象描述元素的有效属性

指定元素.validity.valid



## 6.表单控件-验证有效状态

**验证表单元素的有效状态**

valid 验证是否成功，返回true代表成功

valueMissing 验证是否为空

patternMismatch 验证正则是否匹配

typeMismatch 验证类型是否匹配

rangeUnderflow 验证是否小于

minstepMismatch 验证是否与step匹配

customError setCustomValidity()方法



### 1.valid表单控件是否通过的boolean值

let user = docuemnt.getElementById("user");console.log(user.validity.valid) ->true验证通过，false验证不通过

### 2.valueMissing 非空验证，在表单控件设置了required的时候

```html
<input type="text" id="username" required>

if(username.validity.valueMissing){用户名不能为空}else{通过}
```

### 3.typeMismatch 类型验证，判断email，number或者url类型

```js
if(email.validity.typeMismatch){
    email格式不正确
}else{
    通过
}
```

### 4.patternMismatch 正则匹配

```js
if(phone.validity.patternMismatch){
    电话号码格式不正确
}else{
    通过
}
```

### 5.tooLong 输入的内容大于maxlength属性值的时候为true

```js
if(pwd.validity.tooLong){
    密码不能超过12位
}else{
    通过
}
```

### 6.rangeUnderflow 输入值小于min属性值的时候为true

```js
if(age.validity.rangeUnderflow){
    年龄不符合要求
}else{
    通过
}
```

### 7.stepMismatch 给定的值和min、max以及step不一致的时候为true

```js
if(age.validity.stepMismatch){
    范围设置不正确
}else{
    通过
}
```

### 8.customError 如果元素使用setCustomValidity()方法设置了自定义错误，那么这个状态就是true

```js
if(username.value == ""){
    username.setCustomValidity("用户名不能为空") 
}if(username.validity.customError){
    验证不通过
}
```



## 7.video视频处理

视频处理video

### 1.video标签元素

```html
<video src="./data/xxx.mp4" autoplay></video>
```

### 2.属性

src 引入资源的路径，支持的视频格式：mp4,ogg,webm

autoplay 自动播放视频

source 多个资源

```html
<video>
   <source src="xxx"/>
   <source src="xxx"/>
   <source src="xxx"/>
<video>
```

controls 控制器，提供视频播放的控制面板
loop 视频循环播放
poster 播放之前显示的一张图片
```html
<video src="xxx.mp4" controls poster="xxx.png"/>
```

height,width 视频的宽高
style="background:black" 背景色
preload  预加载，none：不缓存视频，减少不必要的流量；metadata：播放前只加载视频的高度、宽度以及其他此类信息，auto：默认值，要求浏览器尽可能块的下载视频
paused  媒体处于暂停或者未播放状态，这个值是true
ended  如果媒体已经播放结束，这个值为true
duration 返回媒体时长，单位s
currentTime 获取或者设置媒体播放的位置

### 3.方法

play()：播放媒体文件

pause()：暂停播放

load()：加载媒体文件

canPlayType(type)：查看浏览器是否支持这种文件格式的媒体文件

```js
btn.addEventListener("click",function(){
   if(video.paused){  //媒体暂停或者未播放
         video.play(); //开始播放
   }else{
         video.pause(); //暂停播放
   }
})
```



### 4.事件

process：用于更新媒体的下载进度，会周期性的触发

canplaythrough：当整个媒体可以顺利播放时，就会触发这个事件

canplay：不考虑整体状态，主要下载了一定的可放帧就会触发这个事件

ended：媒体暂停播放时触发

pause：媒体暂停播放时触发

```js
video.addEventListener("pause",function(){ 暂停播放 })
```

play：媒体开始播放时触发

```js
video.addEventListener("play",function(){ 开始播放 })
```

error：媒体播放出现错误时触发



## 8.audio 音频处理

音频处理audio

### 1.audio标签元素

```html
<audio src="xxx"></audio>
```

多个音频文件的时候

```html
<audio>
    <source src="xxx"/>
    <source src="xxx"/>
    <source src="xxx"/>
</audio>
```

### 2.属性

src 指定播放文件的地址,mp3,ogg或者wav

controls 可激活各浏览器提供的默认页面

autoplay 加载音频后自动播放

loop 循环播放

preload 缓存设置



## 9.canvas 画布

canvas：html5新标签，提供画布的功能

canvas绘制的图案和html页面无关，无法通过dom获取绘制的图形，也无法为绘制的图案绑定dom事件，只能使用canvas提供的api；

### 1.使用canvas绘制图案

```js
页面创建canvas标签,设置宽高和背景色
<canvas id="canvas" width="500px" height="300px" style="background:pink;"><canvas>
js中获取canvas对象
let canvas = document.getElementById("canvas");
创建画布对象context(2d/3d需要创建的是2D还是3D的效果)
let context = canvas.getContext("2d");
使用画布对象的api去操作画布
context.fillRect(10,10,100,100)    //绘制矩形（x,y,width,height）
context.strokeRect(x,y,width,height)    //绘制空心矩形
context.clearRect(x,y,width,height)     //清除指定区域的矩形
.fillstyle  //设置填充颜色
.strokeStyle  //声明形状线条的颜色
.globalAlpha  //透明度属性，可以设置画布上图形的透明度（0-1）
.createLinearGradient(x1,y1,x2,y2)  //设置线性渐变,(x1,y1)起点，(x2,y2)终点
.createRadialGradient(x1,y1,r1,x2,y2,r2)  //设置射线渐变，扇形
.addColorStop(position,color)    //指定渐变颜色值,position(0-1),color渐变颜色
```



### 2.绘制颜色渐变

```js
设置线性颜色渐变
let canvas = document.getElementById("canvas");
let context = canvas.getContext("2d");
let grd = context.createLinearGradient(0,0,0,canvas.height)  //设置线性渐变createLinearGradient，设置基准线方向
grd.addColorStop(0,"red");grd.addColorStop(0.5,"yellow");grd.addColorStop(1,"blue");   //addColorStop设置渐变颜色
context.fillstyle = grd;   //设置填充颜色（渐变对象）
context.fillRect(0,0,,canvas.width,canvas.height);    //绘制矩形
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200718201357789.png" alt="image-20200718201357789" style="zoom:50%;" />

```js
设置扇形颜色渐变
let canvas = document.getElementById("canvas");
let context = canvas.getContext("2d");
let grd = context.createRadialGradient(canvas.width/2,0,canvas.width/2,canvas.width/2,canvas.height,canvas.width/2)  //设置扇形渐变的基准
grd.addColorStop(0,"red");grd.addColorStop(0.5,"yellow");grd.addColorStop(1,"blue");   //addColorStop设置渐变颜色
context.fillstyle = grd;   //设置填充颜色（渐变对象）
context.fillRect(0,0,,canvas.width,canvas.height);    //绘制矩形
```



### 3.绘制文字

属性：font，textAlign（left，right，center），textBaseline文本基线（top顶部对齐，hanging悬挂基线，middle垂直居中，alphabetic字母基线和bottom底部对齐）

方法：strokeText(text,x,y) 绘制空心文字；fillText(text,x,y)绘制实心文字

```js
let canvas = document.getElementById("canvas");
let context = canvas.getContext("2d");
context.fillText("严跃",100,50);
context.textAlign = "center";
```



### 4.绘制阴影（每一个路径和文字都可以创建阴影效果）

```js
context.shadowColor = "red";   //阴影颜色
context.shadowOffsetX = 0;   //设置水平方向阴影
context.shadowOffsetY = 0;   //设置垂直方法阴影
context.shadowBlur = 10;     //设置阴影的模糊程度
```



### 5.绘制路径

```js
stoke() 将路径绘制成轮廓形状
fill()  将路径绘制为实心形状，使用该方法是可以不用closePath关闭路径，该方法会通过直线连接最后一个点和第一个点实现封闭
stroke()  绘制空心
clip()  在上下文中设置裁剪区域
context.beginPath()   //使用beginPath方法，表示开始创建路径
context.rect(10,10,100,100)  //设置形状-矩形    或者   context.arc(150,10,50,0,Math.PI*2)  x,y,r半径，startAnale，endAngle，direction顺时针（true）逆时针（false）
context.fill()   //绘制  或者  context.stroke()  绘制空心矩形
context.closePath()
```



### 6.绘制线条

```js
canvas.lineWidth = "10";  //设置线型
context.beginPath()
context.moveTo(10,10)   //起点
context.lineTo(100,10)  //终点
context.lineTo()
context.stroke()  
```

![image-20200718201812639](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200718201812639.png)



### 7.绘制图像--处理图片

```js
let imgObj = new Image();
imgObj.src = "xxx.jpg"
context.drawImage(imgObj,10,10);
canvas.createPattern(image,type)   //平铺图片(repeat,no-repeat,repeat-x,repeat-y)
```



### 8.chart.js是一个简单的面向对象的为设计者和开发者准备的图片绘制工具库，可以使用echarts替代

```js
new Chart(ctx).Line(data,options)  曲线图
new Chart(ctx).Bar(data,options)   柱状图
new Chart(ctx).Pie(data,options)   饼状图
new Chart(ctx).Radar(data,options)   雷达图
new Chart(ctx).PolarArea(data,options)   极地区域图
```



## 10.地理定位和Geolocation和拖拽api

### 1.html5的定位技术Ceolocation

是由google公司提供的goole map产品



### 2.使用百度地图

1.申请百度密钥(ak)
2.引入百度地图的js文件

```js
<script src="http://api.map.baidu.com/api?v=2.0&ak=你的密钥"/>
```

3.定义百度地图的元素容器

```js
<div id="baidu-map"/>
```

4.创建百度地图的构造器

```js
let map = new BMap.Map("baidu-map");
```

5.初始化地图，设置中心点坐标和地图界别

```js
map.centerAndZoom(new BMap.point(116.404,39.915));
```

6.添加地图类型控件

```js
map.addControl(new BMap.MapTypeControl());
```

7.设置地图显示城市，次项是必须设置的

```js
map.setCurrentCity("北京");
```

8.开启鼠标滚动缩放

```js
map.enableScrollWheelZoom(true)；
```



### 3.拖拽API

源元素事件
dragstart - 当鼠标开始拖放时被触发
drag - 当鼠标拖放过程中,类似于mousemove事件
dragend - 当鼠标结束拖放时被触发
目标元素事件
dragenter - 当鼠标拖放进入到目标元素内被触发
dragover - 当鼠标到达目前元素被触发为该事件增加event.preventDefault();
drop - 当鼠标实现拖放效果时被触发，默认情况下,该事件没有被触发，原因 - HTML页面默认情况下,不允许拖放，称之为HTML页面的默认行为，解决 - 阻止页面的默认行为，事件对象event.preventDefault()方法
dragleave - 当鼠标拖放离开目标元素被触发
dataTransfer对象
作用 - 类似于window系统的剪切板的功能
功能：可以将源元素的信息(数据),存储在这里，将存储在该对象的源元素信息,提供给目标元素
方法
setData() - 设置(源元素)数据
在源元素事件中使用
getData() - 获取设置的数据
在目标元素事件中使用
clearData() - 清除(设置的)数据
所有的数据内容,存储在浏览器内存中
当使用完毕数据内容时,清除
setDragImage()方法
作用 - 修改拖放过程中,鼠标跟随的图片效果
用法 - drag、dragstart等事件
注意 - 实际操作中,该方法几乎不用



## 11.svg 矢量图

svg：（scalable vector graphics）是一种使用xml技术描述二维图形的语言,扩展名为.svg

svg可以使用3种方式描述二维图形：矢量图，图片，文本

优点：svg可以通过文本编辑器来创建和修改；svg可以被搜索、索引、校本化或者压缩；svg可以在任何分辨率下被高质量的打印；svg可以在图像质量不下降的情况下被放大；



### 1.svg和canvas的区别

svg：不支持分辨率，支持事件处理器；最适合带有大型渲染区域的应用程序（百度地图）；不适合游戏

canvas：依赖分辨率，不支持事件处理器，能够以png和jpg格式保存图像，最适合图像密集型的游戏



### 2.svg绘制图形

绘制矩形 fill填充颜色 stroke描边颜色 stroke-width线条宽度

```html
<svg style="background:pink;width:400px;height:400px;">
<rect x="10" y="10" width="100" height="100" fill="blue" stroke="black" stroke-width="5"/>
</svg>
```

绘制圆形 cx，cy是定义圆点的x和y坐标 r半径

```html
<svg width="500px" height="500px">
<circle cx="100" cy="100" r="100" fill="pink"/>
</svg>
```

绘制椭圆 cx，cy是定义圆点的x和y坐标 rx水平半径 ry垂直半径

```html
<svg width="500px" height="500px">
<circle cx="100" cy="100" r="100" fill="pink"/>
</svg>
```

绘制线条 x1，x2线条开始的位置 x2，y2线条结束的位置

```html
<svg width="500px" height="500px">
<line x1="0" y1="0" x2="300" y2="300" style="sroke:rgb(99,99,99);stroke-width:2" />
</svg>
```

绘制折线 0,0起点 xxx折线点 40,60终点

```html
<svg width="500px" height="500px">
<polyline points="0,0 0,20 20,20 20,40 40,40 40,60" style="fill:white;stroke:red;stroke-width:2" />
</svg>
```

绘制多边形 poins至少需要定义3个点才能设置一个多边形

```html
<svg width="500px" height="500px">
<polygon points=220,100 300,210 170,250" style="fill:#ccc;stroke:#000;stroke-width:1" />
</svg>
```



### 3.two.js 可以绘制svg图案的工具库

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200718202735576.png" alt="image-20200718202735576" style="zoom:50%;" />



## 12.web worker，web存储，web socket

### 1.web workers是运行在后台的javascript

![image-20200718202925307](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200718202925307.png)

![image-20200718202933778](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200718202933778.png)

### 2.web存储API

cookie：使用浏览器作为引用，能存储200kb数据，key-value，不支持中文存储；

sessionStorage：使用单个窗口作为引用，窗口关闭sessionStorage就消失；
sessionStorage.setItem("name","yanyue")
sessionStorage.getItem("name")
sessionStorage.removeItem("name")   sessionStorage.clear()

localStorage：sessionStorage是不允许不同的窗口直接共享数据的，但是localStorage是允许的,只要是同一个程序的就可以；
localStorage.setItem("name","yanyue")
localStorage.getItem("name")
localStorage.removeItem("name")   localStorage.clear()

### 3.websocket

```html
<!DOCTYPE HTML>
<html>
   <head>
   <meta charset="utf-8">
   <title>菜鸟教程(runoob.com)</title>

      <script type="text/javascript">
         function WebSocketTest()
         {
            if ("WebSocket" in window)
            {
               alert("您的浏览器支持 WebSocket!");
               // 打开一个 web socket
               var ws = new WebSocket("ws://localhost:9998/echo");
  
               ws.onopen = function()
               {
                  // Web Socket 已连接上，使用 send() 方法发送数据
                  ws.send("发送数据");
                  alert("数据发送中...");
               };

                
               ws.onmessage = function (evt)
               {
                  var received_msg = evt.data;
                  alert("数据已接收...");
               };

                
               ws.onclose = function()
               {
                  // 关闭 websocket
                  alert("连接已关闭...");
               };
            }
            else
            {
               // 浏览器不支持 WebSocket
               alert("您的浏览器不支持 WebSocket!");
            }
         }
      </script>
        
   </head>
   <body>
      <div id="sse">
         <a href="javascript:WebSocketTest()">运行 WebSocket</a>
      </div>
   </body>
</html>
```



# 3.css

## 1.css的简介和使用

### 1.css的使用

内联样式（直接写在单个html元素中），内部样式表（定义在html的头元素中style）

外部样式表（定义在外部的css文件中）外部引用：

```css
<link rel="stylessheet" type="text/css" href="demo.css">
```

### 2.css优先级

浏览器缺省 < 外部样式表 < 内部样式表 < 内联样式

元素选择器 < 类选择器 < 伪类选择器 < id选择器 < 内联样式



## 2.css选择器+伪类选择器

### 1.通用选择器(*)

*{color:red}

### 2.元素选择器(标签选择器)

html{color:red}

### 3.类选择器(class),可以将多个类写到同一个元素上，实现样式的叠加

.box{color:red}

### 4.元素选择器和类选择器一起使用

div.box{color:red}

### 5.id选择器

#id{color:red}

### 6.群组选择器，逗号隔开，将样式作用在多个选择器上

h1,h2,.box{color:red}

### 7.后代选择器（子孙选择器） 使用空格

.box div{color:red}

### 8.子代选择器 使用 >

.box>div{color:red}

### 9.伪类选择器(:)--用于向某些选择器添加特殊的效果

链接伪类：
xxx:link{} 尚未访问的链接
xxx:visited{} 访问过的链接
动态伪类（用于呈现用户的操作）：
xxx:hover{} 鼠标悬停时候的效果
xxx:active{} html元素激活时候的效果
xxx:focus{} html元素获取焦点时候的效果



## 3.css宽高尺寸和边框border

### 1.尺寸属性

尺寸单位：%，in英寸，cm厘米，mm毫米，pt磅，px像素，em当前字体的宽度；
属性：
宽度：width，min-width，max-width
高度：height，min-height，max-height
字体大小：font-size
可以设置尺寸属性的元素：
块级元素：p，div，h1-h6，ul,ol,li,dl,dt,dd
存在width和height的元素：img，table

### 2.边框 border（border:width style color）

border:1px solid black; 单边定义
border-left/right/top/bottom:width style color;
border-width: 边框宽度
border-left/right/top/bottom-width:width;
border-style: 边框样式
border-left/right/top/bottom-style:style;
border-color:  边框颜色
border-left/right/top/bottom-color:color;
border-radius：边框倒角
border-top-left-radius：边框左上角
border-top-right-radius：边框右上角
border-bottom-left-radius：边框左下角
border-bottom-right-radius：边框右上角
box-shadow：边框阴影
box-shadow:h-shadow必须，水平阴影的位置 v-shadow必须，垂直阴影的位置 blur可选，模糊距离 spread可选，阴影尺寸 color可选，阴影颜色 inset可选，将外部阴影（outset）改为内部阴影;
box-shadow:5px 5px 5px #000 inset;
border-image：图片边框
border-image:source width repeat;
border-image:url(xxxx) 26 round;
border-image-source:图片路径
border-image-width:图片边框的宽度
border-image-repeat:图片边框是否应该平铺（repeat），铺满（round），拉伸（stretch）
outline:轮廓，绘制元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用
outline:color style width;
outline-width:轮廓的宽度
outline-style:轮廓的样式
outline-width:轮廓的颜色

### 3.overflow 溢出处理 overflow-x overflow-y

visible溢出内容可见，
hidden溢出内容隐藏，
scroll无论任何时候都显示滚动条，
auto超过范围才显示滚动条



## 4.box 盒子模型

盒子模型box

height，width->padding->border->margin

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719093600744.png" alt="image-20200719093600744" style="zoom:50%;" />

### 1.width,height指内容区域的宽度和高度

增加内边距、边框、外边距不会影响内容区域的尺寸；但是会增加元素框的总尺寸；
注意：行内元素的宽高是无效的，必须是块级元素；
  行内元素只有margin有效；

### 2.margin外边距

margin-top/right/bottom/left
margin:10px auto;左右是auto就会水平居中；
margin：value 4个方向
margin：上下 左右；
margin：上 左右 下；
margin：上 右 下 左；



## 5.color 颜色单位

颜色单位
rgb(x,x,x) RGB值
rgb(x%,x%,x%) RGB百分比值
#rrggbb  十六进制数
#rgb 简写的十六进制数



## 6.background 背景

### 1.background-color:背景色

会填充元素的内容，内边距和边框（边框没有设置颜色的时候）

### 2.background-image:背景图片

background-image:url(xxx);

background-repeat:背景图平铺效果

repeat,no-repeat,repeat-x,repeat-y

backgorund-size:背景图大小

backgorund-size:width height;

backgorund-size:cover; 使背景图完全覆盖背景区域，但是背景图的某些部分可能无法显示；

backgorund-size:contain; 使背景图扩大到最大尺寸，以使其宽度和高度完全适应内容区域；

backgorund-attachment:背景图是否在页面固定

backgorund-attachment:fixed;

backgorund-position:背景图位置

background-position:left/right/center（水平） top/bottom/center（垂直）;

background-position:center;

background-position:50px 20px; 向右50px 向下20px

background-origin：背景的定位区域

border-box 背景图片相对于边框来定位

padding-box 背景图相对于内边距框来定位

content-box 背景图相对于内容框来定位



### 3.background-clip背景绘制区域

border-box 背景被裁剪到边框盒，为默认值

padding-box 背景被裁剪到内边距框

border-box 背景被裁剪到内容框



### 4.background 背景属性

background:color url(xxx) repeat attachment position;

background:red url("image/demo.jpeg") no-repeat fixed left top;



## 7.渐变 gradient

渐变：指的是2种或者多种颜色之间的平滑过渡；

background-image：属性进行设置

linear-gradient 线性渐变

radial-gradient 径向渐变

repeating-linear-gradient 重复线性渐变

repeating-radial-gradient 重复径向渐变

### 1.线性渐变 linear-gradient:(angle,color-point)

angle:渐变的方向，可以是角度值，也可以是关键词

to top(对应0deg)，to right(对应90deg)，to bottom（对应180deg），to left（对应270deg）

color-point:表示颜色的起始点，中间点和结束点，取值为颜色和位置的组合，如red 0%,green 50%；

background-image:linear-gradient(to bottom,yellow 30px red 90px white 160px)

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719094123117.png" alt="image-20200719094123117" style="zoom:75%;" />

### 2.径向渐变 radial-gradient(size at position,color-point)

position:指定渐变圆心的位置，默认值center，可以取数值、百分比、关键字

color-point:表示颜色的起始点，中间点和结束点，取值为颜色和位置的组合，如red 0%,green 50%；

background-image:radial-gradient(100px at left bottom,yellow red)

background-image:radial-gradient(100px at center,yellow red)

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719094325119.png" alt="image-20200719094325119" style="zoom:70%;" />

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719094333237.png" alt="image-20200719094333237" style="zoom:70%;" />

### 3.重复渐变 repeating-linear-gradient(angle,color-point,...)

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719094353887.png" alt="image-20200719094353887" style="zoom:70%;" />

## 8.文本字体样式 font+text

### 1.字体样式font

font-family 字体类型

font-family:Arial "宋体";

font-size 字体大小

font-size:20px;

font-weight 字体粗细

font-weight:bold;

font-style 字体样式

font-style:italic;

font:font-style font-variant font-weight font-size font-family;

不必每个属性都写，但是必须按照顺序写；



### 2.文本样式text

颜色

color:red;                      

控制文本水平方向排序

text-align:left/center/right;   

行高
line-height:40px;              

首航缩进
text-indent:2em;                

文本阴影
text-shadow:5px 5px 2px black;  

![image-20200719094456191](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719094456191.png)

文本修饰

text-decoration:none/underline;  可以去掉超链接a下面的下划线

文本溢出

text-overflow:clip（裁剪）/ellipsis（隐藏部分之前使用...,只对横向溢出有效）;   

处理空白

white-space:normal/nowrap（文字不换行）;      

长单词换行

word-wrap:normal（正常，长单词不换行）/break-word（长单词会换行）;

文本换行  

word-break:normal/break-all（长单词不换行）/keep-all（无视单词，随意换行）;  

单词之间的间距

word-spaceing:20px；   

英文字母和字母之间，中文汉字和汉字之间的间距

letter-spacing:10px;   



## 9.table 表格样式

table表格

### 1.table样式style

padding 边距、width、height、border（只设置表格本身的边框，不涉及里面单元格的边框）、color、font-size、font-family；
注意：table和td的border是分开设置的；

### 2.table表格特有的样式属性

border-collapse 合并相邻的单元格边框:如果设置了单元格的边框，那么单元格的边框会单独显示，类似于双线边框；
border-collapse:separate(不合并)/collapse(合并单元格的边框)
border-spaceing：设置相邻单元格的边框间的距离，必须要border-collapse:separate的时候才有效
border-spacing:10px（间距）  /  10px(水平间距) 20px（垂直间距）;
caption-side：设置标题的位置 top(表格之上)、bottom(表格之下)，table中必须先定义了标题

```html
 <table><caption>xxxTitle</caption></table>
```

table-layout 表格显示布局属性：
auto（默认值）:列宽度由表格单元格设定，自动表格布局；灵活；
fixed:列宽度由表格宽度和列宽度设定，固定表格布局，如果不做这个定义，即使对宽度做了定义，当表格单元格内容很多的时候，一样会将表格撑大；高效；

### 2.td列

样式style：
border、vertical-align 垂直属性（top/middle/bottom）、text-center、width、overflow、text-overflow:ellipsis;



## 10.float 浮动

float浮动定位，一般给块元素使用

将元素排除在普通流之外（标准文档流），元素将不在页面占据空间

浮动元素只能在父元素范围中浮动

浮动元素的边缘不会超过父元素的内边缘；

浮动元素不会相互重叠；

浮动元素不会上下浮动；

1.float:none、right、left

2.clear:both;   可解决浮动导致的页面bug

3.parent{overflow:hidden} 

当子元素全部使用浮动的时候，这时候父元素和子元素一样就没有高度来，但是正常的页面需要高度，那么我们就需要给父元素添加自适应高度，可以使用overflow属性（溢出隐藏）



## 11.ul-li,ol-li 列表

列表

ul无序列表下只能嵌套子ul或者li

ul、ol下只能编写li，然后li下可以编写其他元素

ul{ list-style:none } 抹去了列表前面的标记

li{ float:left }  li元素全部左浮动，那么列表就可以在同一行显示



## 12.页面布局

### 1.分区（nav，header，tabs，content，footer）

![image-20200719095033594](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719095033594.png)

### 2.body设置

```css
body{
    font-size:12px;
    color:#333;
    background:#f2f2f2;
    font-family:Arial,sans-serif;
}
*{margin:0; padding:0; list-style:none;}
```

### 3.nav导航设置

```css
nav{
    width：100%;
    height:30px;
    border-bottom:1px solid #eee;
    background:#fafafa;
    line-height:30px;
}
tabs,header,content,footer{ width:990px;margin:0 auto; }
tabs{ height:33px;line-height:33px; }
```

### 4.header头部设置

```css
header{ padding:10px 0; }
```

### 5.content内容区域

```css
content:{
    padding-top:30px;
    padding-bottom:20px;
    border:1px solid #ddd;
    border-top:none;
    background:url(xxx) no-repeat 770px 40px #fff;
    height:400px;
}
```



## 13.display 显示方式

display显示方式

块级元素div，h1-h6，p

行内元素span，a

display:none（元素不显示，不占据页面空间）/block（块元素）/inline(行内元素)/inline-block（行内块）;



## 14.显示效果 visibility ，opacity

visibility：元素是否可见

visibility:visible(元素可见)/hidden（元素不可见，但是依然占据空间）/collapse（用在表格布局的时候，可以删除一行或者一列，且不影响表格的布局）;

opacity：元素不透明级别

opacity:0.0(完全透明)-1.0（完全不透明）;



## 15.vertical-align 垂直对齐方式

vertical-align

设置单元格框中单元格内容的垂直对齐方式

设置行内块元素的垂直对齐方式，如img

baseline:默认，元素放置在父元素的基线上

top:把元素顶端和行中最高的元素的顶端进行对齐

bottom：把元素顶端和行中最低的元素的顶端进行对齐

middle:把元素放置在父元素的中部



## 16.cursor 光标样式

cursor光标样式

```css
default、pointer 小手、crosshair、text、wait、help
.btn:hover{
	background:#aaa;
    cursor:pointer;
}
```



# 4.css3

## 1.复杂选择器

### 1.兄弟选择器

相邻兄弟选择器 +

p + b {xxxx}   p元素后的第一个b元素

通用兄弟选择器 ~  （shift+esc下面的的键） 按出来的

p ~  b {xxxx}   p元素后的所有b元素



### 2.属性选择器 []

[属性] [属性] -- 具备一个或者多个属性 

​	div[id] [class] 具备id和class属性的元素

[属性=属性值] -- 属性等于属性值的元素

​	input[type='text']  匹配type的值是text的input元素

[属性`=属性值] -- 属性存在某一属性值的元素

​	input[class`=second]
[属性^=属性值] -- 匹配属性以某个属性值开始

​	input[class^=second]

[属性$=属性值] -- 匹配属性以某个属性值结束

​	input[class$=second]

[属性*=属性值] -- 匹配属性包含某个属性值
	input[class*=second]

[属性!=属性值] -- 匹配属性不等于某个属性值

​	input[class!=second]

### 3.伪类选择器 :

常见的 :hover   :link   :visited   :active

目标伪类

​	:target  突出显示活动的html锚，用于选取当前活动的目标元素

```css
p:target
```


元素状态伪类

```css
:disabled 匹配被禁用的元素    
:enabled 匹配每个被启用的元素   
:checked 匹配被选中的元素（只用于单选按钮和复选框）
```

结构伪类

```css
:first-child   
:last-child   
:empty 匹配没有子元素的元素    
:only-child 父元素下的唯一子元素
```

否定伪类：

​	:not(selector)   	

```css
input:not([type=text])
```

定位选择器的首字母：

​	:first-letter

```css
p:first-letter{xxx}  段落首字母的样式
```

定位选择器的首行：

​	:first-line

```css
p:first-line{xxx}
```

匹配鼠标选取的部分

​	::selection

```css
::selection{xxx}
```

内容生成：content配合:before或:after微元素，插入生成的内容

​	:before   :after

​	content：可以填写字符串text，插入到指定的位置处

```css
p:before{ content:"严跃" };   段落之前插入文本
```

​	content:可以插入图片url

```css
a:before{ content:url(image/link.png) }
```



## 2.transform 变形（旋转，位移，缩放，倾斜）

### transform 变形，迅速变化

指的是元素应用向2D或者#D转化，从而对元素进行旋转、缩放。移动或倾斜；

2D转换：使元素在X轴和Y轴平面上发生变化，改变其形状、尺寸和位置；

3D转换：元素还可以在Y轴发生变化；

transform转换属性：元素应用2D或3D转换，transform:none/transform-function;  没有转换或者转换函数（转换函数可以写多个）

transform-origin转换原点：用来指定元素转换原点的位置，默认情况下，转换的原点在元素的中心点（50%，50%）；

1个值就是所有轴的位置；2个值就是x和y轴的位置(0,0)/(50%.50%),(left/center/right,top/middle/bottom)；3个值就是x，y和z轴的位置；

### 2D变形

rotate 旋转：围绕一个参照原点(transform-origin)，旋转指定的角度，默认顺时针；

```css
transform:rotate(90deg);  //顺时针旋转90度
```

tranlate 位移：沿着坐标方向移动指定的距离,注意：位移不会影响其他元素的位置，但可能会覆盖周围元素；

```css
transform:rotate(180deg)  translate(50px,50px)   向右（x轴）50px，向下（y轴）50px
                          translateX(50px)
                          translateY(50px)   
```

scale 缩放：将指定坐标上的坐标缩放指定的倍速； 0-1缩小，>1放大；

```css
transform:scale(0.5)   //缩小到原来的一半
          scaleX(0.5)
          scaleY(0.5)
```

skew 倾斜：沿着坐标的方向倾斜指定角度；

```css
transform:skew(45deg,45deg)   //沿着x和y的方向倾斜45度
         skewX(45deg)
         skewY(45deg)
```



### 3D变形

perspective设定假定的人眼位置到投影平面的距离，设置在父元素上；

translate 位移：3D位移可以改变元素在z轴上的位置

```css
transform:translate3d(x,y,z)   
          translateZ(z);
```

rotate 旋转：

```css
transform:rotateX(x)   
          rotateY(y);
          rotateZ(z);
```

scale 缩放：

```css
transform:scale3d(x,y,z)   
          scaleZ(z);
```



## 3.transition 过渡

transition过渡，缓慢变化，在一段时间内进行平滑的过渡；

### 1.过渡4要素

过渡属性 transition-property：background（背景变化），color（颜色变化），transform（形状变化）

过渡所需的时间 transition-duration：5s

过渡函数 transition-timing-function：速度和方式

​	ease:默认值，慢速开始，快速变快，慢慢结束

​	linear:均匀过渡

​	ease-in:慢速开始，加速效果

​	ease-out:以慢速结束，减速效果

​	ease-in-out:以慢速开始和结束，中间先加速再减速

过渡延迟时间 transition-delay：激发操作后的执行间隔（s、ms）

```css
{
    transition-property:background,width;
    transition-duration:2s,3s;
    transtion-timing-function:linear,ease;
}
```

### 2.transition:属性名 持续时间  过渡函数  [延迟时间];

```css
{
    transfrom:rotate(720deg);
    transform-origin:center center;
    transition:transform 1s lineat 0s;
}
```

### 3.案例：时钟

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>clock</title>
    <style>
        #clock{
            width: 400px;
            height: 400px;
            border: 6px solid #336699;
            border-radius: 200px;
            position: relative;
        }
        #minute{
            width: 10px;
            height: 100px;
            background: #996633;
            position: absolute;
            top: 100px;
            left: 195px;
        }
        #second{
            width: 6px;
            height: 140px;
            background: #669933;
            position: absolute;
            left: 197px;
            top: 60px;
            transform-origin: 3px bottom;
            transition: transform 60s linear 0s;
        }
        #second:hover{
            transform: rotate(360deg);
        }
    </style>
</head>
<body>
<div id="clock">
    <div id="minute"></div>
    <div id="second"></div>
</div>
</body>
</html>
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719101516754.png" alt="image-20200719101516754" style="zoom:50%;" />



## 4.animation 关键帧动画

关键帧动画animation：

关键帧，动画执行过程中，物体在某一个位置上的特殊状态；

关键帧动画：使用连续的关键帧，控制物体联系的状态变化；

### 1.使用时机

连续，有规律的过渡 -- 过渡transition

无规律的连续变化 -- 动画animation

### 2.使用关键帧动画

1.定义关键帧 @keyframes:IE/火狐   -webkit-keyframes:chrome/safari  -o-keyframes:opera

```css
@keyframes change{
    from{ background:red; }
    10% { background:yellow; }
    50% { background:green; }
    to  { background:pink; }
}
```

2.触发动画 animation:动画名 持续时间 速度类型;

```css
animation:change 5s linear;
```



## 5.css 精灵图的使用

### css sprites的精灵图：可以降低服务器端请求资源的数量，提高性能；

​	通过background-image和background-position进行调整；
​	一般图标的宽高（16*16  32*32）

### 如何使用

定义容器的宽高,超过范围不可见，设置背景图片并且不重复平铺

​		span{ width:17px;height:17px;overflow:hidden;background:url(image/xxx) no-repeat; }

针对不同的容器，设置不同的背景位置，来选择不同的图标

​		span.a1{ background-position: -62px -32px; }

​		background-position设置背景图像的起始位置，这边设置成负值，

​		也就是说背景图片的起始位置在span的外面（左上方），然后span中显示的是我们想要显示的图标位置；

zoom:按比例进行放缩，数字1,2和百分比50%，200%；

transform:scale(x,y):可以进行x和y轴不同方向上的放缩；

### 案例

```css
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>css 精灵图</title>
    <style>
        ul.Sprites{ margin:0 auto; border:1px solid #F00; width:300px; padding:10px;}
        ul.Sprites li{ height:24px; font-size:14px;line-height:24px; text-align:left; overflow:hidden}
        ul.Sprites li span{ float:left; width:17px;padding-top:5px;height:17px;
            overflow:hidden;background:url(image/ico.png) no-repeat}
        ul.Sprites li a{ padding-left:5px}
        ul.Sprites li span.a1{ background-position: -62px -32px}
        ul.Sprites li span.a2{ background-position: -86px -32px}
        ul.Sprites li span.a3{ background-position: -110px -32px}
        ul.Sprites li span.a4{ background-position: -133px -32px}
        ul.Sprites li span.a5{ background-position: -158px -32px}
    </style>
</head>
<body>
<ul class="Sprites">
    <li><span class="a1"></span><a href="#">WORD文章标题</a></li>
    <li><span class="a2"></span><a href="#">PPT内容标题</a></li>
    <li><span class="a3"></span><a href="#">Excel内容标题</a></li>
    <li><span class="a4"></span><a href="#">PDF内容标题</a></li>
    <li><span class="a5"></span><a href="#">文本文档标题</a></li>
</ul>
</body>
</html>
```

![image-20200719102134892](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719102134892.png)

![image-20200719102155790](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719102155790.png)

```css
/*!*设置缩放比例*!*/
div.a6 {width: 34px;height: 34px;overflow: hidden;background: url(image/ico.png) no-repeat -158px -32px;zoom: 2;}
```

![image-20200719102213971](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719102213971.png)

```css
/*可以设置x和y轴不同方向上的放缩*/
div.a6 {width: 34px;height: 34px;overflow: hidden;background: url(image/ico.png) no-repeat -158px -32px; /*设置缩放比例*/
    /*必须设置原点是左上角（默认是中心点）*/
    transform-origin: 0 0;
    transform: scale(2,1);
}
```

![image-20200719102229377](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719102229377.png)

## 6.flex布局

### 1.弹性容器container属性

弹性容器flex container，弹性子元素flex item，主轴flex axis，侧轴cross axis

![image-20200719102817746](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719102817746.png)

#### 设置弹性布局display:flex

```css
display:flex;
```

弹性容器container属性：

#### flex-direction     设置主轴方向，确定弹性子元素排列方式

弹性容器container属性：

flex-direction     设置主轴方向，确定弹性子元素排列方式

![image-20200719102903809](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719102903809.png)

row(默认值)        主轴水平方向，排列顺序和页面的文档顺序相同；

row-reverse        主轴水平方向，排列顺序和页面的文档顺序相反；

column             主轴垂直方向，排列顺序从上到下；

column-reverse     主轴垂直方向，排列顺序从下到上；

![image-20200719103035280](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719103035280.png)

#### flex-wrap 当弹性子元素超过弹性容器范围时是否换行

![image-20200719103049993](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719103049993.png)

nowrap（默认值） 不换行 超过容器的子元素将撑大父元素容器或者挤压子元素，反正不会换行的

![image-20200719103100930](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719103100930.png)

wrap       换行，超过容器的子元素将会自动跳转到下一行或者下一列

![image-20200719103114025](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719103114025.png)

![image-20200719103119595](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719103119595.png)

wrap-reverse   溢出时自动换行，翻转排列

![image-20200719103129533](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719103129533.png)

![image-20200719103133772](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719103133772.png)

#### flex-flow flex-direction和flex-wrap属性的快捷方式，复合属性,设置弹性子元素的排列方式

flex-flow:[[flex-direction] [flex-wrap]]



#### justify-content  主轴上的对齐方式

flex-start  （默认值）      主轴开始对齐，主轴为横轴，ltr环境下，左对齐
flex-end                             主轴结束对齐，主轴为横轴，ltr环境下，右对齐
center                                居中对齐
space-between                第一个，最后一个对齐弹性容器的边缘，其余均匀分布。
space-around          		全部均匀分布

![image-20200719103223013](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719103223013.png)

![image-20200719103227196](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719103227196.png)

flex-start（默认值） 主轴开始对齐，主轴为横轴，左对齐

![image-20200719103237113](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719103237113.png)

flex-end       主轴结束对齐，主轴为横轴，右对齐

![image-20200719103244186](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719103244186.png)

center        居中对齐

![image-20200719103251943](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719103251943.png)

space-between     第一个，最后一个子元素对齐容器的边缘其余子元素均匀分布

![image-20200719103259096](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719103259096.png)

space-around     全部均匀分布

![image-20200719103306211](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719103306211.png)

#### align-items       侧轴上的对齐方式  （主轴如果是水平的话，这边就是设置侧轴垂直方向的对齐方式）

stretch（默认值） 从侧轴开始到侧轴结束铺满整个侧轴，铺满垂直方向
flex-start                 侧轴开始对齐，主轴为横轴，顶对齐
flex-end                  侧轴结束对齐
center                      居中对齐
baseline                  基线对齐（基线就是所有元素下边那块对齐）
align-content          侧轴上有空白时，侧轴的对齐方式（就是侧轴元素不是就一排，并且不是将侧轴铺满的时候）

![image-20200719103504841](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719103504841.png)

stretch（默认值） 各列伸展占用剩余空间，如果剩余空间是负数，该值等于flex-start

![image-20200719103513416](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719103513416.png)

flex-start    侧轴开始对齐，主轴为横轴，顶对齐

![image-20200719103524787](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719103524787.png)

flex-end     侧轴结束对齐，主轴为横轴，底部对齐

![image-20200719103534011](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719103534011.png)

center      居中对齐--垂直方向居中对齐

![image-20200719103542685](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719103542685.png)

space-between   头部和底部到弹性容器的垂直边缘，其余空间均匀分布

![image-20200719103551044](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719103551044.png)

space-around   全部均匀分布

![image-20200719103559138](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719103559138.png)



### 2.弹性子元素item属性

#### 弹性子元素属性：order、flex-grow、flex-shrink、flex-basis、flex、align-self 6个属性

![image-20200719104109591](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719104109591.png)

#### 1.order 设置弹性子元素的顺序

数值小的在前面(可以是负数)

![image-20200719104118828](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719104118828.png)

#### 2.flex-grow 设置弹性子元素的扩展比例

根据扩展比例来分配剩余空间--扩展比例来分配剩余空间，默认为0，不允许为负数，剩余空间根据各个子元素的扩展因子比率来进行分配

![image-20200719104127087](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719104127087.png)

#### 3.flex-shrink 设置弹性子元素的收缩比例

如果子元素的宽度大于容器的宽度，那么子元素将按此比例自动进行收缩--当子元素的宽度大于容器宽度的时候，子元素将按该比例进行收缩；默认值都是1，不允许为负值，也就是一开始都等比例收缩，值越大，收缩越多；

![image-20200719104134010](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719104134010.png)

#### 4.flex-basis 设置弹性子元素的伸缩基准值

默认auto--设置宽度的--flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小，一般就是宽度和高度

![image-20200719104141789](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719104141789.png)

#### 5.flex 是flex-grow，flex-shrink和flex-basis的复合属性

flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。

flex：扩展因子 收缩因子 固有空间

![image-20200719104150956](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719104150956.png)

#### 6.align-self 设置弹性子元素在侧轴上的对齐方式

快速设置单独一个弹性子元素在侧轴上的对齐方式--align-self 单独给一个弹性子元素设置侧轴上的对齐方式

![image-20200719104157353](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719104157353.png)





# 5.js

## 1.js的简介和使用

js的组成：

核心ECMAScript，文档对象模型DOM（document object model）

浏览器对象模型BOM（brower object model）

浏览器内核：

1.内容排版引擎：解析html、css  2.脚本解释引擎：解析js脚本

js程序出错：出错之前的程序正常执行，出错之后的程序不执行



## 2.js的变量var和常量const

### 1.var变量

var username = "yanyue";

变量声明，使用驼峰命名法，且不允许使用关键字

![image-20200719105329871](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719105329871.png)

未经赋值的变量值为undefined

未经声明的变量直接使用的话，会报错ReferenceError

### 2.const常量，一旦赋值就不能修改（基本类型的时候，引用类型还是可以修改的）

const NAME = "yanyue";



## 3.数据类型和类型之间的转换

### js数据类型

5种原始数据类型：Number、String、Boolean、undefined、null

js内置对象（ES标准中定义，浏览器厂商实现）：String，Boolean，Number，Array，Date，RegExp，Math，Error，Function，Object，Clobal

### 隐式类型转换（自动转换）： int->long,float,double,decimal

### 显式类型转换（强制转换）：long->int

long a ;

int b = (int)a;

任意类型转字符串

x.toString()  或者  String(x)

任意类型转数字

parseInt(x)  parseFloat(x)  Number(x)

任意类型转Boolean

Boolean(x)

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719105430741.png" alt="image-20200719105430741" style="zoom:50%;" />

NaN(xxx):是否不是数字

typeof xxx :返回数据类型



## 4.js运算符和表达式

### js运算符

算数运算：+ - * / % ++ --

关系运算：> < >= <= == === !=

​	字符串进行关系比较："yanyue" > "YAYO" 实际上是依次PK每一个字符的unicode编号

​	NaN和任何数据做大小或者等于比较，永远返回false

逻辑运算：&&  ||  !

扩展赋值运算：+=  -=  *=  /=  %=

三目运算符：  xxx?xxx:xxx

举例子：计算闰年

(year%4==0 && year%100 !=0 || year%400==0)?"闰年":"平年";

### js表达式：

由数据、变量和运算符组成的一个公式，每个表达式默认从左向右，两两计算，每个表达式有且仅有一个运算结果；



## 5.函数function

### 函数：

封装一个专门任务的步骤清单的代码段，本质上就是一个引用类型的对象

### 函数声明：

```js
function 函数名(参数){
	代码块;
	[return xxx]
}
```

### 函数调用：

[var 返回值 = ] 函数名(参数);

return:

return单独使用，表示退出当前函数；

return 返回值；结束函数并且只能返回一个返回值；

### 变量作用域：

全局作用域：变量可以在程序的任何位置被访问； 

全局变量：直接在函数外声明的变量；无论任何位置，给从未声明过的变量赋值时

函数作用域：变量仅能在函数调用时，内部被访问；

局部变量：函数内部定义的变量；参数变量天生就是局部变量；

### 常见系统函数：

decodeURI() 解码，服务器端进行解码；

decodeURIComponent()；

encodeURI() 编码，给服务器端发送请求；

encodeURIComponent()；

eval()；

isFinite()；

isNaN()；

parseFloat()；

parseInt()；

alert()；

prompt()；



## 6.分支结构和循环结构

### 1.分支结构

```js
if(){
  xxxx
}

if(){
   xxxx
}else{
   xxxx
}
if(){
   xxx
}else if(){
   xxx      
}else{
   xxx 
}

switch(xxx){
    case "1":
       xxx;
       break;
    case "2":
       xxx;
       break;
    case "3":
    case "4":
       xxx;
       break;
    default:
       xxx;
       break;
}
```



### 2.循环结构

```js
var i = 0; //循环变量

while(i<3){ //循环条件
    xxx;  //循环体
    i++;
}

do-while循环，循环体执行执行一次
var i = 0;
do{
    xxx;
    i++;
}while(i<3)
    
for(let i=0;i<3;i++){
	xxx;
}
```



### 3.break退出当前层循环 continue退出当前循环执行下一次循环

常常和if判断一起使用；



## 7.数组Array

数组：一组连续的变量组成的集合

### 创建数组：

var arr = [1,2,3,4]  

var arr = new Array(1,2,3.4)

### 使用下标（从0开始）进行赋值和取值

arr[1] = xxx;

var a = arr[1];

### 使用null去释放对象，undefined未定义的对象

undefined：是所有没有值的变量的默认值，自动赋值

null：当使用完一个较大的对象的时候，主动释放对象是好习惯

### 垃圾回收站：

当一个对象不被任何变量引用的时候，会被释放

### js数组特殊情况：下标越界不会出错；

js数组为不存在的位置赋值不会出错，会自动创建指定下标
从不存在的位置取值也不会出错，也不会增加新的元素，而是返回undefined

### 数组的操作

1.获取数组的长度 arr.length

2.数组的遍历

```js
for(let i=0;i<arr.length;i++){
循环体;
}
```



### 关联数组：可以自己定义下标名称的数组（类似json）,管理数组中的length无效

关联(hash)数组，下标不能重复，优势使用hash算法，缺点：遍历查找元素只能从头开始；

```js
var arr = [];
arr["name"]="yanyue";
arr["age"]=26;
let age = arr["age"];
```

遍历关联数组：

```js
for(let key in arr){
	arr[key];
}
```



### 数组API（实例方法）：toString,join,indexOf,slice,splice等

> toString转字符串

let str = arr.toString();   //数组转字符串，元素使用,隔开，连接成一个数组

[1,2,3,4] -> 1,2,3,4

> join连接

let str = arr.join("-");    //join数组连接，使用定义的连接符号连接成一个字符串

[1,2,3,4] -> 1-2-3-4

> indexOf返回指定元素的下标

let index = arr.indeOf(item)   //indexOf

> concat拼接

let newArr = arr.concat(新值,数组,新值...)  //数组拼接，原对象不变，返回新对象

> slice截取

let newArr = arr.slice(start,end)          

//数组截取，含头不含尾，原对象不变，返回新对象，end如果不写，就表示从start一直取到尾部

> splice删除、插入、替换  会修改原始数组

arr.splice(index,1);  删除指定下标的元素，返回被函数的元素

arr.splice(index,0,"yanyue","YAYO");  插入：在指定的下标后面插入新的元素

arr.splice(index,1,"yanyue","YAYO");  替换：移除指定下标位置的元素，并且替换芯的元素

> reserve翻转，会修改原对象

arr.reserve()

> sort排序,缺陷：默认将所有元素转成字符串进行升序比较，会修改原对象

arr.sort();

可以编写sort比较器函数

```js
function compareNum(a,b){ return a-b; }
function compareNumDesc(a,b){ return -(a-b); }
arr.sort(compareNum);
```



### 栈和队列：js中没有真正意义上的栈和队列类型，都是使用数组对象模拟的；会修改原对象；

> 栈stack：只能从末尾一端进出的数组

push，pop从数组的末尾添加获取元素，已经入栈的元素下标不变；

```js
let stack = [];

stack.push(xxx); stack.pop();
```

unshift，shift从数组的开头添加获取元素，已经入栈的元素位置都会向后顺移；

```js
let stack = [];

stack.unshift(xxx); stack.shift();
```

> 队列queue：只允许末尾进push，开头出的数组shift；

```js
let queue = [];
queue.push(xxx);  queue.shift()
```



### 二维数组：

```js
let arr = [[1,2],[3,4]]
```

访问二维数组 arr [1] [1]

遍历二维数组

```js
for(let i = 0;i<arr.length;i++){
	for(let j = 0;j<arr[i].lenbth;j++){
 	  arr[i][j];
	}
}
```



## 8.字符串String

字符串：多个字符组成的一个只读的集合（数组）

### 1.转义字符

\' 单引号   \"双引号   \& 和号   \\ 反斜杠    \n 换行符   \r 回车符  \t 制表符   \b 退格符   \f 换页符

### 2.字符串大小写转换 toUpperCase toLowerCase

```js
str.toUpperCase();
str.toLowerCase();
```

### 3.获取指定下标的字符 [i],charAt,charCodeAt

```javascript
str[i]

let char = str.charAt(i)

str.charCodeAt(i)   返回字符的unicode码
```

### 4.查找关键子的下标 indexOf，lastIndexOf，可以判断字符串是否存储，存在就返回下标，不存在返回-1

```js
字符串中是否包含include
let i = str.indexOf("x",[startIndex]);
let i = str.lastIndexOf("x",[startIndex]);
let bool = "yanyue".includes("y");
if(srcStr.indexOf(str) !== -1){
	存在;
}else{
	不存在;
}
```

### 5.获取子字符串slice，substring，subStr

```js
slice   
let newStr = str.slice(startIndex,[endIndex]);

substring   
let newStr = str.substring(startIndex,[endIndex]);  不支持负数参数

subStr     
let newStr = str.subStr(startIndex,[count]);  count截取几个字符
```

### 6.将字符串分割成数组split("分隔符")

```js
let arrStr = str.split(",");
```

### 7.模式匹配 search查找  match匹配  replace替换

```js
查找：
let index = str.search(reg); let arr[] =  str.match(reg);
加上i忽略大小写：
let index = str.search(/kword/i);
加上g就是全部：
let arr = str.match(/kword/ig);  //返回所有关键词的内容，返回的是关键词数组
替换： 
str.replace(reg);
let newStr = str.replace(keyword,"xxx");
```

### 8.重复输出 repeat(num)

```js
str.repeat(10);  //重复输出10次
```

### 9.eval() 是js的全局函数，计算js的字符串，并且把它作为脚本输出

```js
eval("1+2+4") //7
eval("[1,2,3,4]") //[1,2,3,4]
```

### 10.判断字符串是否以xxx开始startsWith，或者以xxx结尾endsWith

```js
console.log( "yanyue".startsWith("y") );
console.log( "yanyue".endsWith("y") );
```



## 9.正则表达式和正则对象RegExp

### 1.正则表达式

\d  [0-9]：1位数字

\w  [0-9a-zA-Z]：1位数字、字母或下划线

\s  [空字符]：代表一位空字符：空格，Tab符

.   除了换行外，其他所有的字符

量词：{min,max}{min,}

不确定数量： {0,1}最多1次，{0,}随意，{1,}至少1次

> 字符集：

[abc]匹配到abc中任意一个字符；
[^abc]匹配不再abc中的字符；
[0-9]匹配任意数字；
[a-z]匹配任何小写字母；
[A-Z]匹配任何大写字母；
[A-z]匹配任意字母

> 预定义字符集：

\d 匹配一个数字               /\d/等价于/[0-9]/
\D 匹配一个非数字             /\D/等价于/^[0-9]/
\w 匹配一个数字/字母/下划线   /\w/等价于/[0-9a-zA-Z]/
\W 匹配一个非数字/字母/下划线 /\W/等价于/[^0-9a-zA-Z]/
\s 匹配一个空白字符(space)    /\s/等价于/[\n\r\f\t\v\f]/
\S 匹配一个非空白字符         /\S/等价于/[^\n\r]/

> 数量词：

n?   匹配0次或者1次字符n   /a?/
n*   匹配0次或者多次字符n  /a*/
n+   匹配1次或者多次字符n  /a+/
n{x} 匹配字符n出现n次      /a{3}/
n{x,y} 匹配字符n出现x次到y次   /a{2,4}/
n{x,}  匹配字符n出现>=x次   /a{3,}/

> 条件选择 exp1|exp2，分组(exp1)：

   (+86|0086)

> 指定匹配的位置：

^    匹配字符串的开头     /^a/
$    匹配字符串的结尾     /a$/
\b   匹配单词的边界       /\bhis\b/
\B   匹配单词的非边界     /\Bhis\B/
?=x  匹配其后紧接x的字符串  /do(?=not)/
?!x  匹配其后没有紧接x的字符串  /do(?!not)/

### 2.RegExp对象

创建正则对象：
let reg = /正则表达式/ig;
let reg = new RegExp("正则表达式","ig");

API方法：

> search判断有没有,返回下标，缺点：不能指定开始的位置

let reg = /^\d{6}$/;
let index = str.search(reg);

> match格式验证,返回所有关键字内容数组，缺点：不能返回位置

let reg = /^\d{6}$/;
let arr = str.match(reg);

> test格式验证,返回boolean值

let reg = /^\d{6}$/;
let bool = reg.test(str);

> exec查找，返回查询到的str数组,需要加g

let reg = /^\d{6}$/g;
let arr = reg.exec(str);

> replace替换

let newStr = str.replace(reg,"替换值");

> split切割

let arr = str.split(reg);

### 3.正则的贪婪模式和懒惰模式

默认贪婪模式：默认总是匹配最长的符合条件的字符串，原因：.*或.+等引起；
懒惰模式：仅匹配最短的符合条件的字符串，原因：(.*?)



## 10.1.数字Number

### 1.数字Number

在js中，数字不分为整数和浮点数类型，所有的数字都是浮点数类型，均为64位；
精度：整数最大位数是15位，小数最大位数是17位；
Infinity 无穷大  -Infinity 无穷小

> 1.进制转换，js中的数字默认是10进制的，可以通过toString(xxx)来进行进制的转换

let num = 128;
num.toString(16) - 80;num.toString(8) - 200;num.toString(8) - 10000000;

> 2.isNaN(xxx) 不是数字，数字返回false，不是数字返回true

isNaN(1000) - false
isNaN("yanyue")  - true

> 3.数字可以是数字，也可以是对象

let x = 11,y = new Number(11);
typeof(x) - Number  typeOf(y) - Object

> 4.toFixed()指定保留几位小数

let result = num.toFixed(2); //保留2位小数

### 2.Number属性

Number.MAX_VALUE 		最大值

Number.MIN_VALUE		最小值

Number.NaN		非数字
Number.NEGATIVE_INFINITY		负无穷，在溢出时返回

Number.POSITIVE_INFINITY		正无穷，在溢出时返回

Number.EPSILON		表示 1 和比最接近 1 且大于 1 的最小 Number 之间的差别

Number.MIN_SAFE_INTEGER		最小安全整数

Number.MAX_SAFE_INTEGER		最大安全整数。

### 3.Number的API方法

Number.parseFloat()

​	将字符串转换成浮点数，和全局方法 parseFloat() 作用一致。

Number.parseInt()

​	将字符串转换成整型数字，和全局方法 parseInt() 作用一致。

Number.isFinite()

​	判断传递的参数是否为有限数字。

Number.isInteger()

​	判断传递的参数是否为整数。

Number.isNaN()

​	判断传递的参数是否为 isNaN()。

Number.isSafeInteger()

​	判断传递的参数是否为安全整数。



## 10.2.Math计算对象

### 1.Math对象属性

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719142758998.png" alt="image-20200719142758998" style="zoom:50%;" />

Math.PI 圆周率



### 2.Math的API方法

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719142817666.png" alt="image-20200719142817666" style="zoom:80%;" />

Math.abs(x)    返回绝对值

Math.ceil(x)   向上取整  5->5 5.1->6

Math.floor(x)  向下取整  5.9->5 5->5

Math.max(x,y)  返回最大值   数组的话需要使用apply： Math.max.apply(Math,arr); Math.max(arr);

Math.min(x,y)  返回最小值

Math.pow(x,y)  返回x的y次幂

Math.round(x)  返回x的四舍五入的整数 5.4->5 5.5->6

Math.random()  随机数0-1之间  0-100之间的随机数 Math.randow()*100;



## 11.Date日期对象

Date对象：封装了一个时间点，提供了对时间和日期操作的API‘

### 1.创建Date对象

```js
let now = new Date();
let date = new Date("xxxx/xx/xx [xx:xx:xx]")
```



### 2.日期API

```js
let date = new Date();    //返回当前的日期和时间
date.getDate();           //从Date对象中返回一个月中的某一天 (1-31)
date.getDay();            //从Date对象中返回一周中的某一天 （0-6）
date.getMonth();          //从Date对象中返回当前月份 (0-11)
date.getFullYear();       //从 Date 对象以四位数字返回年份
date.getYear();           //请使用 getFullYear() 方法代替

date.getHours();          //返回 Date 对象的小时 (0 ~ 23)
date.getMinutes();         //返回 Date 对象的分钟 (0 ~ 59)
date.getSeconds();         //返回 Date 对象的秒数 (0 ~ 59)
date.getMilliseconds();    //返回 Date 对象的毫秒(0 ~ 999)
date.getTime();            //返回 1970 年 1 月 1 日至今的毫秒数
date.getTimezoneOffset();  //返回本地时间与格林威治标准时间 (GMT) 的分钟差
date.setDate();            //设置 Date 对象中月的某一天 (1 ~ 31)
date.setMonth();           //设置 Date 对象中月份 (0 ~ 11)
date.setFullYear();        //设置 Date 对象中的年份（四位数字）
date.setYear();            //用 setFullYear() 方法代替
date.setHours();           //设置 Date 对象中的小时 (0 ~ 23)
date.setMinutes();         //设置 Date 对象中的分钟 (0 ~ 59)
date.setSeconds();         //设置 Date 对象中的秒钟 (0 ~ 59)
date.setMilliseconds();    //设置 Date 对象中的毫秒 (0 ~ 999)
date.setTime();            //以毫秒设置 Date 对象
date.toString();            //把 Date 对象转换为字符串
date.toTimeString();        //把 Date 对象的时间部分转换为字符串
date.toDateString();        //把 Date 对象的日期部分转换为字符串
```



## 12.Error异常处理

### 1.js中常见几种错误类型：

SyntaxError    语法错误
ReferenceError 引用错误，找不到变量或者对象
TypeError      类型错误，错误的使用了对象中的方法时
RangeError     范围错误，参数超出范围
EvalError      调用eval函数的时出错
URLError       URL错误

### 2.错误处理

```js
try{
	代码段;
}catch(err){
	发生错误时执行的代码段;
}finally{
	一定会执行的代码段;释放资源之类的
}
```



### 3.抛出自定义异常 throw new Error("自定义异常");

```js
function fun1(num){
    if(isNaN(num)){
       throw new Error("不是数字")
    }else{
       alert("OK");
    }
}
function fun2(input){
    try{
       fun1(input);
    }catch(err){
       alert("输入必须是数字");
       console.log(err.toString());
    }
}
```



## 13.Function函数

函数Function：js中的函数其实就是引用函数定义对象的变量

### 1.arguments对象--函数的参数对象

参数不一样可以实现方法的重载；
arguments[i];
arguments.length

### 2.创建函数的3种方式

1.函数名和函数定义都被提前

function a(){};

2.仅函数名变量声明会提前，函数定义留在本地

var a = function(){};

3.使用new创建函数类型对象

var a = new Function("a","b","函数体");

### 3.内存中的函数对象

创建函数的时候创建2个对象；

函数对象fun：函数的定义；作用域链对象：保存了函数对象可用的变量位置（引用变量）；默认第一项指向window对象

调用函数的时候，又会创建一个新对象;

活动对象：专门保存局部变量的对象，在作用域链对象中追加指向活动对象的引用；

调用之后，默认仅释放活动对象，作用域链中的活动对象出栈；

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719143256204.png" alt="image-20200719143256204" style="zoom:50%;" />

### 4.匿名函数（一次性函数）：定义时候不能指定函数名称

> 自调函数：

匿名函数自调

定义完，立即执行，执行完立即释放；

何时使用，只有确定函数只执行一次的时候

如何自调，(function(参数){xxx})(参数值);

自调，定义在哪就在哪执行，不提前；

```js
let a = 100;
(function(a){
	a++;
	console.log(a);  //101
})(a);
console.log(a);  //100
```



> 回调函数：

匿名函数回调
将函数作为对象传递给另一个函数的时候，由另一个函数自主决定在需要的时候调用
何时使用，只要将一个函数对象传递给其他方法调用时
如何回调，直接将匿名函数的声明传入另一个函数中

```js
arr.sort(function(a,b){ return a-b; })
```



### 5.闭包--解决全局对象和局部对象的缺陷

闭包：就是指能读取其他函数内部变量的函数

由于在js中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单的理解成“定义在一个函数内部的函数”

所以，本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁；

简单的说就是将父函数中的局部变量，写一个全局函数将这个变量作为结果返回；

这时这个函数是在内存会一直在内存中保存这个结果；

这样这个结果是在函数内部创建的，但是又可以长久的保存，实现共享；

问题：全局变量和局部变量的缺陷，全局变量：容易全局污染，局部变量：无法共享，不能长久保存；

闭包：既可以共享，长久存储，又不会全局污染

> 闭包实现3步骤：

定义外层函数，封装被保护的局部变量；

定义内层函数，执行对外层函数局部变量的操作；

外层函数返回内层函数的对象，并且外层函数被调用时候，结果被保存在全局变量中；

```js
function outer(){   //外层函数
var n = 1;  //被保护的变量
function inner(){  //内层函数，修改外层变量
   return n++;
}
return inner;  //外层函数返回内层函数对象inner
}
var getNum = outer();
getNum() //1
getNum() //2
var n = 100; //假设有全局污染
getNum() //3 不受影响
getNum() //4
```

何时使用：反复调用局部变量，又避免全局污染的时候，要使用闭包；

> 闭包3特点：

嵌套函数；

内层函数操作了外层函数的局部变量；

外层函数将内层函数返回到外部，被全局变量保存住；

判断闭包运行的结果：

外层函数被调用几次就有几个受保护的局部变量的副本；

来自一个闭包的函数被调用几次，受保护的局部变量就变化几次；



### 6.onload函数：当页面加载完成，自动触发

```js
<script>
window.onload = function(){
	xxx;
}
</script>
```



## 14.js面向对象，原型链

对象：封装多个数据的存储空间，对象包含属性和方法；

### 1.创建对象

```js
var obj = { 属性名:值,属性名:值... }
```


js中一切都是对象，对象的底层是hash数组；

### 2.属性访问

obj.属性名

obj["属性名"]

访问不存在的属性不会出错，但是会返回undefined；

强行给不存在的属性赋值时，不报错！js会自动创建同名属性；

判断一个对象是否存在一个属性

obj.hasOwnProperty("属性名") ->true/false

"属性名" in obj ->返回true或者false

obj.属性名!==uundefined  如果不包含，返回值是undefined，返回false,如果包含，返回的是值或者function，返回的是true

### 3.this关键字

this指的是正在调用方法的对象；

比如在方法中，访问当前对象自己的属性；this.xxx；

### 4.封装、继承、多态

封装：将描述同一个东西的属性和方法，定义在一个对象中

继承：父对象中的属性和方法，子对象可以直接使用

多态：同一个对象，在不同的情况下，呈现不同的状态；重载，同一个方法名，传入不同的参数，执行不同的操作；重写，子对象觉得父对象中的成员不好用，可以自己定义，覆盖父对象的成员；

#### 1.封装：创建对象3种方式

1.var obj = { 属性名:值,"方法名":function(){} }
2.var obj = new Object();  obj.属性名=值;  obj.方法名=function(){};
3.使用构造函数：

```js
定义构造函数
function 构造函数名|类名(属性参数){
	this.属性名 = 属性参数;
	this.方法名 = function(){
	}
}
```

构造函数创建对象
var obj = new 构造函数|类型名();
流程:1.创建一个空对象new Object();2.用空对象调用构造函数，构造函数给空对象添加属性和方法；3.设置新对象的__proto__指向构造函数的prototype对象；4.返回新对象的地址；

#### 2.继承：js中一切继承都是用原型对象实现的

prototype原型对象（对象原型）：每个函数对象都有一个原型对象，构造函数的原型对象保存所有子对象共享成员；其实所有内置类型的API都是定义在类型.prototype中

```js
yanyue.__proto__ = Student.prototype;  //Student类的原型对象
```

扩张对象属性：

扩展公有属性:(通过构造函数.prototype添加的属性)； Person.prototype.name = "yanyue"; 

判断是否是共有属性："属性名" in obj && !obj.hasOwnProperty("属性名")   在原型链中包含但是子对象中没有的属性

扩展自有属性：通过某一个具体子对象添加的属性；

```js
obj.hasOwnPeoperty("属性名")
```

删除属性：

```js
delete 对象.属性名  只能删除对象自己的属性，无法删除共有属性
```

原型（原型对象）：保存所有子对象共有属性和方法的对象；（实体类）

所有的函数都有prototype，指向自己的原型对象；

所有的对象都有__proto__,指向自己父级原型对象；

原型对象都有constructor属性，指向自己的构造函数；

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719191037110.png" alt="image-20200719191037110" style="zoom:50%;" />

对象原型链（所有父子级对象之间通过__proto__形成的多级引用关系）：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719191049464.png" alt="image-20200719191049464" style="zoom:67%;" />

普通对象的原型链：lilei.__proto__ = Student.property;  Student.prototype.__proto__ = Object.prototype;  Object.prototype.__proto = null;

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719191104501.png" alt="image-20200719191104501" style="zoom:50%;" />

![image-20200719191111788](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719191111788.png)

构造函数的原型链：由各级对象的__proto__逐级继承形成的关系，获得任意对象的父级原型对象；

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719191125070.png" alt="image-20200719191125070" style="zoom:50%;" />

#### 3.API：

isPrototypeOf 检查对象的原型   父对象.isPrototypeOf(子对象)

typeof(xxx) 判断对象的类型

Array.isArray(arr) 判断是否是数组

obj instanceof Array 判断对象是否被构造函数创建

constructor属性：

obj.constructor == Array;

toString():

Object.prototype.toString.call(obj) == "[object Array]"

call,apply；call在调用方法的一瞬间更换调用方法的对象

父子继承：

创建子对象：Object.create(父对象,[属性列表]);

创建一个空对象，继承空对象中的属性，继承的同时可再扩展属性和方法；



### 5.原型链

![image-20200719191228988](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719191228988.png)



## 15.dom文档对象模型

### 1.dom简介

#### 1.dom文档对象模型（document object model）：

html dom：正对html文档的对象模型，通过dom可以访问所有的html元素，连同它们包含的文本和属性；

#### 2.常用dom属性

innerHTML
parentNode
childNodes
attributes

#### 3.常用dom方法

getElementById();
getElementsByTagName();
getElementsByClassName();
appendChild();
removeChild();
insertBefore();
createAttribute();
createElement();
createTextNode();
getAttribute();
setAttribute();

#### 4.DHTML模型

DHTML：Bynamic HTML，动态HTMl，不是一种技术、标准或规范，只是一种将目前已有的网络技术，语言标准整合使用，制作出能在下载后仍然实现变换页面元素效果的网页设计概念；

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719202303373.png" alt="image-20200719202303373" style="zoom:80%;" />

### 2.dom树，节点树node和元素树element

#### 1.dom树

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719203251603.png" alt="image-20200719203251603" style="zoom: 67%;" />

#### 2.节点树：

将HTML DOM文档视作树结构；树根为document对象，通过document对象来操作整个节点树；
document node：整个文档节点；
element node：每个html标签是一个元素节点；
text node：包含在html元素中的文本是文本节点；
attribute node：每一个html属性是一个属性节点；
comment node：注释属于注释节点；

#### 3.document对象：

浏览器内置的js解释器会为载入的每个html文档创建一个对应的document对象
通过使用document对象，可以从脚本中对html页面中的所有元素进行访问

#### 4.Node类型节点的对象类型和继承关系

nodeType：表明节点类型的数值常量，元素节点返回1，文本节点返回3；
nodeName：节点的名称，元素节点返回标签名，文本节点返回#text；
nodeValue：节点的内容,元素节点返回null，文本节点返回文本内容；
chilNodes：获取当前节点对象下的所有子节点数组

#### 5.节点之间的关系(父子，兄弟)

parentNode父节点，childNodes子节点，firstChild第一个子节点，lastChild最后一个子节点，
previousSibling上一个兄弟节点，nextSibling下一个兄弟节点，

#### 6.节点操作

节点查找
var ele = document.getElementById("id");
var eles = document.getElementsByTagName("标签名");
var eles = parent.getElementsByName("name属性值");
创建节点
创建元素节点：
var newEle = documenewElent.createElement("标签名");
设置必要属性：newEle.innerHTML = "hello world";
将节点挂载到父节点下：parent.appendChild(newEle);
创建文本节点：
var msg = document.createTextNode("text");
创建注释节点：
var c = document.createComment("xxxx");
创建文档片段：
var fragment = document.createDocumentFragment();
插入节点
parentNode.appendChild(childNode) 父元素下追加一个子节点；
parentNode.insertBefore(newChild,existChild) 父元素指定子节点之前添加一个新的子节点
删除节点
parent.removeChild(oldEle);
oldEle.parentNode.removeChild(oldEle);
替换节点
parent.replaceChild(newEle,oldEle);

#### 7.元素树（Node节点类型除了定义节点之间关系属性外，还定义了一套元素节点间关系属性），IE8以下不支持

parentElementNode 获取父元素
children 获取子元素结合
firstElementChild 获取第一个子元素
lastElementChild 获取最后一个子元素
previousElementSibliing 获取上一个兄弟元素
nextElementSibiling 获取下一个兄弟元素

#### 8.修改元素的内容和属性

innerHTML 获取、设置元素开始标签和结束标签之间的html原文
innerText：获取开始标签和结束标签之间文本
ele.attributes：获取属性集合
ele.getAttribute("属性名")：读取元素的属性值
ele.getAttribute("属性名","属性值")：修改属性值
ele.removeAttribute("属性名")：移除属性
ele.hasAttribute("属性名")：判断属性是否存在



## 16.bom浏览器对象模型

### 1.bom简介

bom浏览器对象模型

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719203517044.png" alt="image-20200719203517044" style="zoom:67%;" />

window：表示浏览器中打开的窗口；
navigator：包含有关浏览器的信息；
screen：包含有关客户端显示屏幕的信息；
history：包含用户（在浏览器窗口中）访问过的url；
location：包含当前url的信息；
document：包含当前浏览器加载的文档信息；
event：包含当前所触发的事件对象；

### 2.window对象

#### window对象：专门操作浏览器窗口的对象

window对象，2个角色：充当全局对象，包含bom常用对象；
window对象是bom对象的根对象，其他的bom对象都是它的属性，如document对象；
如果文档中包含frame或者iframe标签，浏览器会为html文档创建一个window对象，并为每个框架创建一个额外的window对象；



#### window对象常用对象属性：

defaultStatus:设置或返回窗口状态栏中的默认文本
innerheight:返回窗口的文档显示区的高度
innerwidth：返回窗口的文档显示区的宽度
length：设置或者返回窗口中的框架数量
name：设置或返回窗口的名称
opener：返回对创建此窗口的窗口的引用
outerheight：返回窗口的外部高度
outerwidth：返回窗口的外部宽度
pageXOffset:设置或返回当前页面相对于窗口显示区左上角的X位置
pageYOffset:设置或返回当前页面相对于窗口显示区左上角的Y位置
parent：返回父窗口
self：返回当前窗口的引用
status：设置窗口状态栏的文本
top：返回最顶层的先辈窗口



#### 打开链接的4种方式：

[window].open("url","_seld");  -- 在当前窗口打开新连接，可以后退
[window].open("url","_blank");  -- 在新的窗口打开链接，可以打开多个
location.replace("新的url");  -- 在当前窗口打开新的链接，禁止后退

```html
<a href="xxx" target="_self/_blank"></a>
```



#### 窗口的大小和定位：

> 窗口定位：获取窗口位置的坐标：

- 左上角x坐标：window.screenLeft||window.screenX
- 左上角y坐标：window.screenTop||window.screenY
- event.screenX/screenY:事件发生时，鼠标距离显示器左上角的坐标

> 移动窗口位置：

- window.moveTo(newX,newY);
- window.moveBy(changeX,changeY);



### 3.navigator对象

navigator对象：包含了浏览器的信息，常用于获取客户端浏览器和操作系统信息；
常用属性
appCodeName：返回浏览器的代码名
appMinorVersion：返回浏览器的次级版本
appName：返回浏览器的名称
appVersion：返回浏览器的平台和版本信息
browserLanguage：返回当前浏览器的语言
cookieEnabled：返回指定浏览器中是否启用cookie的布尔值；判断浏览器是否可用cookie   window.navigator.cookieEnabled
cpuClass：返回浏览器的cup等级
onLine：返回指明系统是否处于脱机模式的布尔值
platform：返回运行浏览器的操作系统平台
systemLanguage：返回OS使用的默认语言
userAgent：返回由客户机发送服务器的user-agent头部的值
userLanguage：返回OS的自然语言设置

### 4.history对象

history对象：window对象中保存当前窗体访问过的url的历史记录栈
hostory.go(n)
hostory.go(1)
hostory.go(-1)
hostory.go(0) 刷新当前页面

### 5.location对象

#### location对象：location中包含着当前URL的信息，常用于获取和改变当前浏览的网址

获取当前页面的url：let url = location.href;
更改当前页面的url: location.href = "http://www.baidu.com"

#### 常用属性：

hash：设置或者返回从#开始的URL（锚）
host：设置或者返回主机名和当前URL的端口号
hostname：设置或者返回当前URL的主机名
href：设置或者返回完成的URL
pathname：设置或者返回当前URL的路径部分
port：设置或者返回当前URL的端口号
protocol：设置或者返回当前url的协议
search：设置或者返回从？开始的url（查询部分）

#### 常用方法：

assign() : 加载新的文档
reload() : 重新加载当前文档
replace() : 用新的文档替换当前文档

### 6.screen对象

screen对象：包含客户端显示屏幕的信息，常用于获取屏幕的分辨率和色彩；
常用属性和方法：
availHeight：返回显示屏幕的高度（除windows任务栏之外）
availWidth：返回显示屏幕的宽度（除windows任务栏之外）
bufferDepth：设置或返回调色板的比特深度
colorDepth：返回目标设备或者缓冲器上的调色板的比特深度
deviceXDPI：返回显示器屏幕的每寸水平点数
deviceYDPI：返回显示屏幕的每英寸垂直点数
fontSmoothingEnabled：返回用户是否在显示控制面板中启用了字体平滑
height：返回显示屏幕的高度
width：返回显示器屏幕的宽度
logicalXDPI：返回显示屏幕每英寸的水平方向的常规点数
logicalYDPI：返回显示屏幕每英寸的垂直方向的常规点数
poxelDepth：返回显示屏幕的颜色分辨率（比特每像素）
updateInterval：设置返回屏幕的刷新率

### 7.event对象

event对象：当用户和web页面进行某些交互的时候，解释器就会创建相应的event对象以描述事件信息；

#### 1.常见的事件：

用户点击某项内容；
鼠标经过特定元素；
用户按下键盘；
用户滚动窗口或者改变窗口大小；
页面元素加载完成或者失败

#### 2.常见属性：

srcElement、target：事件源对象
eventPhase：事件所处的传播阶段
clientX、offsetX、pageX、screenX：事件发生的x坐标
clientY、offsetY、pageY、screenY：事件发生的y坐标
which/keyCode/charCode：键盘事件中按下的按键
button：鼠标那个按键按下了
cancelBubble：是否取消事件冒泡
returnValue：是否阻止事件默认行为

#### 3.事件处理函数：

鼠标事件：onclick，ondbclick，onmousedown,onmouseup,onmouseover
键盘事件：onkeydown，onkeyup，onkeypress
状态事件：onload，onunload，onchange，onfocus，onblur，onresize，onsubmitonreset，onerror

#### 4.事件定义（3种方式）：

<button onclick="xxx">按钮</button>  直接在html中定义元素的事件相关性

```js
btnObj.onclick = function(){ }  在js中为元素的时间属性赋值
btnObj.attachEvent("onclick",function(){})   高级事件处理，一个时间可以绑定多个函数
btnObj.addEventListener("click",function(){})
```



#### 5.事件周期：解释器创建一个event对象后，会按照如下过程将其在html元素之间进行传播

第一阶段：事件捕获，事件沿着dom树向下传播
第二阶段：目标触发，运行事件监听函数
第三阶段：事件冒泡，事件沿着dom树向上传播

#### 6.获取event对象：

函数中直接使用event关键字就可以获取event对象；

#### 7.取消冒泡：当某一事件触发后，如果不想继续往上层冒泡，可在当前时间处理函数结尾取消冒泡；

```js
function(e){
if(e.stopPropagation){
   e.stopPropagation();  //其他浏览器
}else{
   e.cancelBubble = true;  //ie
	}
}
```



#### 8.取消默认事件：浏览器在事件传递并处理完可能会执行该事件的默认动作，例如input type=submit，点击会自动提交表单

```js
if(event.preventDefault){
	event.preventDefault();
}else{
	event.returnValue = false; //ie
}
```



#### 9.事件坐标：event对象记录事件发生时的鼠标位置

相当于浏览器显示区坐标的位置：clientX|clientY
相当于网页右上角坐标位置：pageX|pageY
没有滚动时候，上面2个值是相等的
相对于屏幕坐标位置：screenX|screenY
相对于目标元素左上角的坐标位置：offsetX|offsetY



## 17.jquery

### 1.jquery简介

#### 1.jquery的简介

js代码分为内部对象和外部对象，内部对象是js自带的，但是外部对象针对的是浏览器，这个时候就存在兼容性的问题；

jquery是一种js框架，封装了js的底层，同时封装了一套API，用于兼容各种浏览器，实现真正的通用；

实现html和js的解耦；jquery是一个优秀的js框架，一个轻量级的js库；封装了js、css、dom，提供了一致的简洁的API；兼容css3以及各种浏览器；

使用户更加方便的处理html、events、实现动画效果，并且方便的为网站提供ajax交互；使用户的html页面保持代码和html内容的分离；

#### 2.在html的head头部引入使用jquery

```js
<script type="text/javascript" src="./js/jquery-1.11.1.js"></script>
```



### 2.jquery对象

#### jquery对象：

jquery是为了解决浏览器兼容性问题而提供的一种统一封装后台的对象描述；

jquery提供的方法都是针对jquery对象特有的，而且大部分方法的返回值类型也是jquery对象，所以方法可以连续

调用，jquery对象.方法().方法（）...;

jquery对象获取：$("div") $("#id")

jquery对象的本质是一个DOM的数组对象，它在该数组扩展了一些操作数组中元素的方法；

let $username = $("username");  let username1 = $username[0];

属性:length

方法：eq(index),get(),index(obj)根据dom对象返回对应的下标

jquery中的遍历：

$(xxx).each(callback);

$.each(obj,callback);

#### dom对象转换成jquery对象：

let username = documenrt.getElementById("username");
let $username = $(username);

#### jquery对象转换成dom对象：

let $username = $("#username");
let username = $username[0];

### 3.jquery选择器

#### 1.jquery选择器：定位元素，调用方法；

选择器种类：基本选择器，层次选择器，过滤选择器，表单选择器

#### 2.基本选择器

元素选择器：$("标签名")
类选择器：$(".class")
id选择器：$("#id")
选择器组(逗号隔开)：$("#id,.class")

#### 3.层次选择器

$("select1  select2")  子孙选择器
$("select1 > select2") 子选择器
$("select + select2")  兄弟选择器，下一个弟弟
$("selet1~select2")    所有的弟弟

#### 4.基本过滤选择器

:first   第一个元素
:last    最后一个元素
:not(selector)   把selector排除在外
:even    挑选偶数行
:odd     挑选奇数行
:eq(index)  下标等于index的元素
:gt(index)  下标大于index的元素
:lt(index)  下标小于index的元素
:header     匹配h1-h6的标题元素
:animated   匹配正在执行动画效果的元素

#### 5.子元素过滤选择器

:nth-child(下标)  匹配父元素下的子元素
:first-child      获取父元素下的第一个子元素
:last-child       获取父元素下的最后子元素
:only-child       获取父元素下的唯一一个子元素

#### 6.内容文本过滤选择器

:contains(text)   匹配包含给定文本的元素   $("p:contains('严跃')")
:empty            匹配所有不包含子元素或文本的空元素   $("p:empty")
:parent           匹配含有子元素或者文本的元素    $("div:parent")
:has(selector)    过滤出选择器种类的元素    $("div:has('.mini')")

#### 7.可见性顾虑选择器visibility

:hidden  匹配所有不可见元素  type为hidden的input元素
:visible  匹配所有可见元素

#### 8.属性过滤选择器attribute

$("div[属性名]")含有某个属性的div元素
$("div[属性名=属性值]")含有某个属性=属性值的div元素
$("div[属性名!=属性值]")含有某个属性！=属性值的div元素  $("div[title!=text1]")
$("div[属性名^=属性值]")元素属性值以什么开始的div元素
$("div[属性名$=属性值]")元素属性值以什么结尾的div元素
$("div[属性名*=属性值]")元素属性包含属性值的div元素
$("div[属性名*=属性值][属性名*=属性值]")多个属性过滤器并列使用

#### 9.表单对象状态过滤器，经常用来选择表单的inpit中的内容

:enabled  匹配可用的元素
:disabled  匹配不可用的元素
:checked  匹配选中的checkbox   $("input[name=favourite]:checked")
:selected  匹配选中的option    $("city>option:selected")

#### 10.表单选择器：主要用来选择表单控件的

:text   匹配文本框
:password   匹配密码框   $("#form:password")
:radio   匹配单选框
:checkbox   匹配多选框
:submit   匹配提交按钮
:reset   匹配重置按钮
:button   匹配普通按钮
:file   匹配文件框
:hidden   匹配隐藏框



### 4.jquery操作dom

jquery操作dom：

#### 1.读写节点

读写节点的html内容
obj.html()  obj.html("<span>123</span>");  
读写节点的文本内容
obj.text()  obj.text("123");
读写节点的value属性值
obj.val()   obj.val("abc");
读写节点的属性值，删除节点的属性
obj.attr("属性名")  obj.val("属性名","属性值");  obj.removeattr("属性名")

#### 2.创建节点

$("节点内容")，text()文本节点，attr()属性节点

#### 3.插入节点

parent.append(obj)  作为最后一个子节点添加进来
obj.appendTo(parent);
parent.prepend(obj) 作为第一个子节点添加进来
obj.prependTo(parent);
brother.after(obj)  作为下一个兄弟节点添加进来
brother.before(obj)  作为上一个兄弟节点添加进来

#### 4.删除节点

obj.remove() 删除节点本身和它的子节点
obj.remove(selector) 删除满足条件的子节点
obj.empty() 清空该节点的所有子节点

#### 5.替换节点

$("节点1").replaceWith("节点2");  节点1被节点2替换

#### 6.复制节点

$("节点1").clone(true).appendTo(parent);

#### 7.样式操作

obj.attr("class","big")  设置样式
obj.addClass("big")      追加样式
obj.removeClass("big")   移除样式     obj.removeClass()  移除所有样式
obj.toggleClass("big")   切换样式，已经存在该样式的时候添加该样式，没有该样式的时候就添加该样式
obj.hasClass("big")      判断是否有该样式
obj.css("color")         读取css样式值
obj.css("color","blue")  设置css样式值

#### 8.遍历节点

obj.children([selector])   直接子节点
obj.next([selector])       获取下一个兄弟节点
obj.prev([selector])       获取上一个兄弟节点
obj.sibilings([selector])  获取所有的兄弟节点
obj.find([selector])       获取带条件的子节点
obj.parent([selector])     获取父节点



### 5.jquery事件处理

jquery事件处理：

#### 1.ready()--页面加载函数

$(document).ready(function(){ xxx })
window.onload = function(){ xxx }
ready和onload的区别：
ready：具有简写的方式；在一个html页面中允许多个；等待html页面中所有dom结构加载完毕后就可以执行；ready加载快一点；
onload：没有简写方式；一个html页面中只能一个；必须等待html页面中所有内容加载完毕后才能执行；

#### 2.jquery加载函数

$(function(){
//这里表示的内容表示js只有在dom元素全部加载结束后才会执行
})
注意：将js代码写在dom底部或者js文件在dom底部引入，这样可以保证在dom加载完毕之后，给已经渲染好的dom元素绑定js事件；

#### 3.事件是否会自动执行

```
obj.click(showme());  //自动执行
obj.click(showme);    //点击执行
obj.click(function(){
	showme();
})
```



#### 4.事件的绑定和解除

绑定事件：bind(type,data,fn)，type指定绑定的事件名称，如果绑定多个事件用逗号或者空格隔开，data对象的额外参数，fn绑定事件的处理函数；
绑定多个事件：$obj.bind("mouseover mouseout",function(){})
解除绑定：unbind(type)
结束元素的事件绑定：$obj.unbind();
常见事件：blur，focus，focusin，focusout，load，resize，scroll，unload，click，dbclick，mousedown，mouseup，mousemove，mouseover，mouseout，mouseenter，mouseleave，change，select，submit，keydown，keypress，keyup，error
绑定事件的简单写法:click()事件就是bind('click')的简写方式

```js
$obj.bind('click',fn);简写成：$obj.click(fn);
```



#### 5.获取事件对象event

事件对象event：
事件对象记录了事件发生时鼠标位置、键盘按键状态和触发对象等信息，事件对象的常用属性：
srcElement/target      ：事件源对象,返回的是doom对象
eventPhase             ：事件所处的传播阶段
clientX/offsetX/pageX/screenX/x  ：事件发生的x坐标
clientY/offsetY/pageY/screenY/y  ：事件发生的y坐标
which/keyCode/charCode  ：键盘事件中按下的按键
button                  ：鼠标哪个按键被按下了
cancelBubble            ：是否取消事件冒泡
returnValue             ：是否阻止事件默认行为
获取事件对象：

```js
$obj.click(function(e){ xx })
```

取消事件冒泡：

```js
$obj.click(function(e){ xxx;e.sropPropagation(); })
```

取消事件冒泡：
$obj.click(function(e){ xxx;e.sropPropagation(); })

#### 6.jquery合成事件：

hover(over悬停函数,out离开函数) -- 模拟光标悬停事件

```js
$("img").hover(function(){xxx},function(){xxxx});
toggle(f1,f2,f3) -- 几个函数按照顺序切换实现
```



### 6.jquery动画

jquery动画：

#### 1.显示show()/show（执行时间、回调函数）、隐藏hide()/hide(执行时间、回调函数)

执行时间：slow,normal,fast或者毫秒数
回调函数：动画执行完毕之后要执行的函数

```js
$obj.show('slow',function(){ alert('xxx') });
```



#### 2.上下滑动 slideDown(speed，callback)向下滑动、slideUp(speed，callback)向上滑动 来显示和隐藏

```js
$("button").click(function(){
	$("div").slideDown();
})
```



#### 3.slideToggle（speed，callback）--对象会变成一个上下自动滑动的效果图

#### 4.淡入淡出 fadeIn()\fadeIn(执行时间,回调函数)、fadeOut()\fadeOut(执行时间,回调函数)来显示和隐藏,通过改变不透明度opacity来实现的

```js
$("#msg").fadeIn(2000).fadeOut(1000);
```



#### 5.自定义动画效果animate（动画样式,执行时间,回调函数）

偏移位置--图片向上(top -)下(top +)，做左（left -）右(left +)移动
$("img").animate({"left":"500px"},2000); 
$("img").animate({"left":"500px"},500).animate({"left":"-250px"},500);
图像拉伸--横向拉伸（width px）、纵向拉伸（height px）

```js
$("div").animate({"height":"300px"},2000)
 .animate({"width":"300px"},2000)
    .animate({"height":"100px"},2000)
    .animate({"width":"100px"},2000);
```



### 7.this的用法

#### 1.具有上下问环境的时候使用this,this指代的是上下文环境

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719214557028.png" alt="image-20200719214557028" style="zoom:80%;" />

#### 2.javascript构造器中使用this，this指代的是new出来的对象

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719214614114.png" alt="image-20200719214614114" style="zoom:80%;" />

#### 3.JQuery的隐式迭代中使用this，this指代的是dom元素

![image-20200719214643156](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719214643156.png)



### 8.jquery中的ajax

jquery中ajax的使用

#### 1.3层封装

封装第一层：类似原生ajax的语法   $.ajax()最复杂
封装第二层：基于第一层再次封装 load()  $.get()   $.post()
封装第三层： $.getScript()动态读取脚本（js代码），$.getJson()接受json格式数据

> $().load(url,data,callback);

最简单，但是局限性最大；url地址，data请求参数，callback（data）回调函数
缺点：请求类型不确定，数据只能是key-value，只能接受字符串类型数据

> $.get(url,data,callback,type)

url地址，data参数（key-value），callback回调函数（形参是data，返回值），type服务器端响应数据的格式（默认html格式，xml格式，json格式）

```js
$.get("02.php",user,function(data){
   console.log(data);
},"json");
```

> $.post(url,data,callback,type)

```js
$.post("city.php",data,function(data){
   console.log(data);
},"json")
```

$ajax() -- 最复杂

```js
$.ajax({
   url : "04.php",
   type : "post",
   async : true,
   data : user,
   success : function(data,textStatus){
         console.log(data);
         console.log(textStatus)
   },
   error : function(XMLHttpRequest,textStatus, errorThrown){
         console.log(textStatus);
         console.log(errorThrown);
         }
   });
   });
```

> $.getScript(url,callback) 动态读取脚本

```js
$("#btn").click(function(){
   $.getScript("script1.js");
})
```



#### 2.跨域请求

完全跨域：IP不同，跨子域：IP相同，端口不同；
万维网协议：默认是不允许跨域访问的，同源策略的影响；所谓同源：域名、协议、端口相同；

```js
$.getJson("1.php",function(data){
   console.log(data);
})
```

因为html的script标签是一个例外，利用script具有开放策略，网页可以从其他源动态产生json资料，这种模式叫jsonp；

因为html的script标签是一个例外，利用script具有开放策略，网页可以从其他源动态产生json资料，这种模式叫jsonp；



## 18.http请求和响应码

### 1.URL

url：统一资源定位符；ip地址+端口+路径?查询数据#锚
uri：统一资源标识符；
区别：所有的url肯定是uri，但是uri不一定是url；

### 2.网络协议

常见方案：http,https,ftp,mailto,rtsp,file,news,telnet等；
http（默认80端口），https加密协议（默认443端口），socket，ftp协议；
常见请求类型：get获取数据,post传递数据,head,put新增数据,delete删除数据,options,trace

### 3.状态码

#### 1xx - 服务器端信息

#### 2xx - 表示请求成功

 200 请求成功
 201 创建连接
 202 接受请求

#### 3xx - 表示重定向

 302 表示重定向
 304 表示服务器端资源没有变化，访问缓存（问题：这次请求没有真正的访问服务器端）
 305 表示使用代理

#### 4xx - 客户端错误

 400 错误的请求
 401 unauthorized未授权
 403 拒绝访问
 404 网页找不到
 405 请求类型不允许

#### 5xx - 服务器端错误

 500 服务器端错误
 502 路径错误
 504 请求超时
 505 http版本不支持





# 6.es6

## 1.es6开发环境 

es6开发环境：大多数浏览器还不能完全识别es6语法。需要将其转换成es5的语法，这样浏览器才可以识别；
创建项目

npm init

安装npm的包

npm i babel-cli babel-preset-es2015 -D

编写.babelrc文件

```js
{
  "presets": [
    "es2015"
  ],
  "plugins": []
}
```

编写js文件，然后执行编译脚本,将es6语法编译成es5

"build": "babel src/index.js -o dist/index.js"

```
let username = "yanyue"   -> var username = "yanyue"
```



## 2.let const变量声明

var变量声明，var声明的变量是全局声明，会污染js的全局作用域；
let const块级作用域

### let局部声明：

let a = 10,b = 20,name="yanyue";

let不像var那样子，会发生变量提升的现象；

暂时性死区：只要块级作用域内存存在let命令，它所声明的变量就“绑定”这个区域，不受外部影响；

let不允许在相同的作用域内，重复声明同一个变量；



### const常量声明：

一旦声明，常量的值就不能改变；

块级作用域，暂时性死区，同一个区域内不能声明同名常量；

注意：const声明之后不能改变的是这个值所在的内存地址，

  如果值是数组等可序列化的变量的时候，数组本身是可以改变的；只要常量中的地址不变就可以了，
  为const常量重新赋值内存地址是不可以的；
  const对象或者const数组属性或元素可以修改，但是对象或数组本身不能更换；

### 全局对象属性：

全局对象是最顶层的对象，浏览器中指的是window对象，nodejs环境中指的是global对象；

es6规定，let const class命令声明的全局变量不属于全局对象的属性，var和function声明的变量数据全局变量的属性；



## 3.解构赋值{xxx}

### 1.数组解构

let [a,b,c] = [1,2,3];

let [a,b] = [1,2,3];  //不完全解构

let [a=1] = [];  //没有值的时候可以设置默认值（===undefined的时候才会使用默认值）



### 2.对象的解构，可以设置默认值

let {username,age} = {username:”yanyue”,age:25};

let {username,age=18} = {username:”yanyue”,age:25};



### 3.字符串的解构赋值

const [a,b,c,d,e,f,g] = “yanyue”;

const {length} = "yanyue";   //字符串属性解构赋值，length属性，返回字符串的长度



### 4.函数参数的对象解构，数组解构

```js
function fun1({a,b=’web’}){
	console.log(a,b);
	}
fun1({a:”yanyue”,b:”YAYO”});

function fun1([a=1,b]){
	console.log(a,b);
	}
fun1([2,3]);
```



### 5.函数参数的数组解构--数组解构

```js
function fun2(a,b,c){ console.log(a,b,c) };
let arr = [1,2,3];
fun2(...arr);
```



### 6.in 判断对象或者数组中是否存在某个值,主要是判断的key

```js
let obj = {username:”yanyue”,age:25};
console.log(“username” in obj); -- true
```

![image-20200719191949373](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719191949373.png)

![image-20200719192004648](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719192004648.png)

数组的话判断的就是下标了，没得多大意义；



### 7.解构用来交互变量的值，非常方便

[x,y] = [ y,x ];



## 4.扩展运算符...和rest运算符...

### 1.对象扩展运算符...

```js
function fun1(...arg){ console.log(arg[0]) };
fun1(1,2,3);
```

### 2.可以使用对象扩展符进行对象的浅拷贝（一层）

```js
let arr1 = [‘a’,’b’,’c’];
let arr2 = arr1;  //这边直接使用=
console.log(arr2);
arr2.push(“yanyue”);
console.log(arr1);  //上面给arr2添加了新的元素，但是arr1本身也被改变了
这边arr1和arr2本质上使用了同一块内存数据；
解决： 这个时候修改arr2的话，arr1不会发生变化；互补影响
let arr2 = [...arrr1];
```



### 3.rest(剩余)运算符 -- 主要用于声明一个方法的时候的对象不确定性

```js
function fun1(first,...arg){  //剩余的参数（函数展开符号，不定长参数）
	console.log(arg.length) ;
	for(let val of arg){
	console.log(val);
	}
} ;
fun1(0,1,2,3);
注意:
for(xxx in arr){ xxx返回的是元素的序号0,1,2 }
for(xxx of arr){ xxx返回的是元素的值value }
```



## 5.模板字符串 ``

### 1.可以进行变量输出，可以自动编译字符串中的html标签

```js
我的姓名是${username}，性别是${sex}，<br/>年龄是${age}
```

### 2.支持运算

```js
计算结果是${a+b}`
```



## 6.Number数字操作

### 1.Number.isFinite(num);  //判断是否是数字

Number.isFinite(11.5) - true
Number.isFinite(“yanyue”) - false
Number.isFinite(NaN) - false
Number.isFinite(undefined) - false

### 2.Number.isNaN(xxx) 是否不是数字(数字返回false，不是数字的返回true)

Number.isNaN(11) - false;

### 3.Number.isInteger(xxx) 是否是整数

Number.isInteger(110) - true

### 4.Number.parseInt(xxx) 将数字转换成整数，丢掉小数部分

Number.parseInt(11.9) - 11



## 7.Array数组操作

### 1.json的数组格式,Array.form(json)将json数据转换成数组

```js
let json = {
    “0”:”yanyue”,
    “1”:”YAYO”,
    “2”:”KOKO”,
     length:3
}
let arr = Array.from(json);  //将json转换成数组
[“yanyue”,”YAYO”,”KOKO”]
```



### 2.Array.of(xxx) 可以将数据转换成数组

```js
Array.of(1,2,3,4) - [1,2,3,4]
```



### 3.eval 计算js的字符串(性能低下)

```js
eval(“[1,2,3,4]”) - [1,2,3,4]
```



### 4.find实例方法,查找对数组进行过滤返回

```js
let arr = [1,2,3,4,5];
	let result = arr.find(function(value,index,arr){
	return value > 5;
})
```



### 5.fill实例方法，填充

```js
let arr = [“yanyue”,”yan”,”yue”];
arr.fill(“web”,1,3);  //用web去填充替换arr中的下标1到3之间的元素
```



### 6.of数组循环

```js
for(let item of arr){
	console.log(item)；
}
for(let item of arr.keys()){
	console.log(item)；
}
for(let [index,value] of arr.entriest()){
	console.log(index)；
	console.log(value)；
}
```



### 7.数组遍历forEach，没有返回值，可以进行遍历的操作 -- （数组遍历）

```js
arr.forEach((val,index)=>{
	console.log(index,val);
})
```



### 8.数组过滤filter，返回新的数组 -- 数组过滤

```js
let newArr = arr.filter(x=>x>10);
```



### 9.数组遍历map，返回新的数组

```js
let newArr = arr.map(item=>{ return item*2; })
```



### 10.数组遍历some，只要有一个满足条件就返回true，不然返回false -- 是否存在元素通过测试

```js
let bool = arr.some(item=>{item>10})
```



### 11.数组遍历every，只要有一个为false，结果就是false，要求全部满足条件通过才为true -- 所有元素是否通过测试

```js
let bool = arr.every(item=>{item>10})
```



### 12.数组对象的合并，返回新的数组

```js
let newArr = [...arr1,...arr2];
```



### 13.数组对象的去重

```js
let uniqueArr = [...new Set(arr)];
```



### 14.获取数组的首位和末尾元素和剩余的元素

```js
let [head,...rest] = arr;
let [last,...rest] = arr.reverse();
```



## 8.object对象操作

ES6对象

### 1.es6中可以直接使用变量进行赋值

```js
let username = “yanyue”
let obj = {username:username}  //es5中需要这样进行赋值
let obj = {username}  //es6中可以直接使用变量进行赋值
获取对象的属性值
obj.name
如果属性名中存在空格的话
obj.["user name"]
```



### 2.key值的构建，对象中的key值可以是一个变量

```js
let key = “username”;
let obj = {
	[key]:”yanyue”;
}
console.log(obj);  {username:”yanyue”};
```



### 3.自定义对象的方法，es5中也有的

```js
let obj = {
add:function(a,b){
	return a+b;
	}
}
console.log(obj.add(1,2));
```



### 4.es6中的is(),判断对象是否相等

```js
let obj1 = {username:”yanyue”}
let obj2 = {username:”yanyue”};
console.log(obj1.username === obj2.username);  //true
console.log(Object.is(obj1.username,obj2.username));  //true
区别：
+0 === -0 //true   NaN === NaN  //false  同值相等
Object.is(+0,-0) //false  Object.is(NaN,NaN) //true  严格相等
```



### 5.assign对象的合并

```js
let newObj = Object.assign(target,...source);  //newObj和target的值都会被改变，2者一样
let newObj = Object.assign({},...target,...source);   //这样可以避免target的值被修改
let name = {username:”yanyue”};
let age = {age:25};
let sex = {sex:0}
let person = assign(name,age,sex);
let yanyue = {};
let newPerson = Object.assign({},yanyue,{name:"yanyue",age:25});
```



### 6.对象Object的方法

```js
Object.keys(obj)  返回对象的key数组
Object.values(obj)  返回对象的value数组
Object.entries(obj)   返回对象的key-value数组
let newObj = {...obj1,...obj2};  对象合并，返回新的对象
let newObj = Object({},obj1,obj2)
```



### 7.可以通过Object.setPrototypeOf修改一个对象的属性

```js
Object.setPrototypeOf(MiMi,wangting);
console.log(MiMi.getName()); //wangting
console.log(Object.getPrototypeOf(MiMi) == wangting); //true
```



## 9.Symbol对象的元素保护

Symbol在对象中的使用 -- 很少使用
常用的数据类型：String，Number，Boolan，Array，Object，

### 1.Symbol数据类型

```js
let f = Symbol();
typeof f  //symbol
```



### 2.Symbol主要可以实现对象中key值的构建，主要是实现对象元素的保护作用

```js
let key = Symbol();
let obj = {
	[key]:”yanyue”
}
console.log(obj[key]);   //yanyue
```

实现对象属性的保护,如果我对象元素循环输出的时候，不想别人知道age这个属性的值

```js
let obj = {name:”yanyue”,age:28,skill:”web”}
for(let key in obj){
	console.log(obj[key]);
}
let age = Symbol();
let obj = {name:”yanyue”,skill:”web”}
obj[age] = 18;
console.log(obj);
```

![image-20200719193256839](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719193256839.png)

```js
for(let key in obj){
	console.log(obj[key]);
}
```

循环输出的时候，没有age这个属性的值

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719193320456.png" alt="image-20200719193320456" style="zoom:50%;" />

如果想获取age的值，需要直接书写obj[age]才可以得到



## 10.Set和WeakSet结构

Set和WeakSet数据结构

### 1.Set是es6新出的，功能：数组去重,缺点只能放数组，如果对象的话，使用WeakSet

```js
let setArr = new Set([“yanyue”,”YAYO”,”KoKo”]);
```



### 2.add 追加元素

```js
setArr.push(xxx)  //错误的，set是不可以使用push去添加新的元素的
setArr.add(xxx) ;  //正确的，set只能通过add去添加新的元素js
```



### 3.has查找

```js
setArr.has(“yanyue”)  // true
```



### 4.clear清除所有数据

```js
setArr.clear();
```



### 5.delete(xxx) 删除某个数据

```js
setArr.delete(“yanyue”);
```



### 6.遍历 for of  forEach都可以进行遍历

```js
for(let item of setArr){
	console.log(item)
};
setArr.forEach(item=>{
	console.log(item);
})
```



### 7.size获取set的长度

```js
setArr.size
```



### 8.WeakSet可以放置对象,如果放置2个内存地址不同的对象还是会都添加进行的，只有相同地址的相同对象才会进行去重处理，所有感觉用处不大

```js
let weakSet = new WeakSet({xxx:xxx});  //错误，不能直接赋值对象的
let weakSet = new WeakSet();
let obj = {username:”yanyue”,age:20};
weakSet.add(obj);  //必须通过add来添加对象，直接添加会报错的
console.log(weakSet);
```



## 11.Map数据结构

map数据结构

### 1.创建一个map对象

```js
let map = new Map();
```



### 2.set添加元素key-value

```js
map.set(“username”,”yanyue”);
```



### 3.get获取元素

```js
map.get(“username”)   //”yanyue”
```



### 4.delete删除元素,clear清空元素

```js
map.delete(“username”);
map.clear();
```



### 5.size获取长度

```js
map.size
```



### 6.查找has

```js
map.has(“username”);
```



### 7.遍历map

```js
//获取键值对
for (let [key, value] of map) {
  console.log(key);
  console.log(value);
}
//获取键名
for(let [key] of map){
  console.log(key);
}
//获取值
for(let [,value] of map){
  console.log(value);
}
```



## 12.函数和箭头函数

箭头函数和扩展

### 1.设置函数参数默认值

```js
function(a=1,b=2){ return a+b;}
```



### 2.函数参数的展开操作符  ...rest参数

```js
function breakfast(dessert,drink,...foods) {
  console.log(dessert,drink,foods);
}
```



### 3.解构参数

```js
function add ({a,b,{c,d}}){ xxx }
add({a:"",b:"",{c:"yanyue",d:"YAYO"}})
```



### 4.箭头函数

```js
let fun1 = (a=1,b=2) => a+b;
let fun1 = (a=1,b=2) => { return a+b;};
```

普通函数：

```js
var obj = {
id: "a",
cool: function coolFn() {
    console.log( this.id );
    }
};
var id = "b"
obj.cool(); // a
setTimeout( obj.cool, 100 ); // b 这边obj中输出id的值不是a，而是b了
```

问题在于cool() 函数丢失了同this 之间的绑定。（最好的解决方法也是最常用的解决方法是var self = this。） ：这也是我vue中习惯每个函数前面写 let vm = this;的原因；

箭头函数：

```js
var obj = {
count: 0,
cool: function coolFn() {
    if (this.count < 1) {
        setTimeout( () => {
        this.count++;
    console.log( "a" );
    }, 100 );
   }
  }
};
obj.cool(); // a
```

注意：箭头函数的作用域this就是箭头函数所在的词法作用域，也就是触发或者调用该箭头函数的模块对象
总结：简单来说，箭头函数在涉及this 绑定时的行为和普通函数的行为完全不一致。它放弃了所有普通this 绑定的规则，取而代之的是用当前的词法作用域覆盖了this 本来的值。因此，这个代码片段中的箭头函数并非是以某种不可预测的方式同所属的this 进行了解绑定，而只是“继承”了cool() 函数的this 绑定（因此调用它并不会出错）。箭头函数的绑定无法被修改。（new 也不行！ ） 



## 13.proxy实现对象的增强

使用proxy进行预处理

### 1.es6增强对象和函数（方法），生命周期的预处理get获取属性之前执行,set修改对象属性时执行

```js
let obj = {
	add:function(val){ val+100 },
	name:”yanyue”
}
let pro = new Proxy(obj,{
get:function(target,key,property){
	// get就是在调用属性之前进行调用
	console.log(“come in get”);
	//返回属性值
	return target[key];
},
set:function(target,key,value,receiver){
	//set方法就是在修改属性值的时候调用
	console.log(`setting ${key} = ${value}`);
	return target[key] = value;
	}
})
console.log(pro.name)  //先执行get方法，然后返回属性值
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719200237202.png" alt="image-20200719200237202" style="zoom:67%;" />

```js
pro.name = “YAYO”; //修改对象属性值的时候会调用proxy中的set方法
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719200246924.png" alt="image-20200719200246924" style="zoom:67%;" />

### 2.apply对函数进行增强,方法执行之前执行

```js
let target = function(){ return “yanyue” };
let handle = {
	apply(target,ctx,args)(){
	console.log(“do apply”);
	return Reflect.apply(...arguments);
	}  
}
let pro = new Proxy(target,handler);
console.log(pro());
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719200307023.png" alt="image-20200719200307023" style="zoom:67%;" />



## 14.promise对象的使用

promise对象的使用

### 1.解决es5中的回调地狱的问题

```js
let state = 1;
function step1(resolve,reject){
	console.log(“1.开始-洗菜做饭”)
	if(state == 1){
   		resolve(“洗菜做饭--完成”)
	}else{
  		 reject(“洗菜做饭--错误”)
	}
}

function step2(resolve,reject){
	console.log(“2.开始-坐下来吃饭”)
	if(state == 1){
   		resolve(“坐下来吃饭--完成”)
	}else{
   		reject(“坐下来吃饭--错误”)
	}
}

function step1(resolve,reject){
	console.log(“3.开始-收拾桌子洗碗”)
	if(state == 1){
       resolve(“收拾桌子洗碗--完成”)
	}else{
   		reject(“收拾桌子洗碗--错误”)
	}
}

new Promise(step1).then(val=>{
	console.log(val);
		return new Promise(step2);
	}).then(val=>{
		console.log(val);
		return new Promise(step3);
	}).then(val=>{
		console.log(val);
})
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719201411574.png" alt="image-20200719201411574" style="zoom:50%;" />

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200719201417329.png" alt="image-20200719201417329" style="zoom:50%;" />



## 15.class类的使用

class类的使用:本质上是prototype的语法糖

### 1.声明一个类class

```js
class Coder{
    //构造函数
    constructor(a,b){
    this.a = a;
    this.b= b;
    }
	//静态方法可以通过类名直接调用
	static cook(food){
   		console.log(food);
	}
	//成员方法
	name(val){
   		console.log(val);
   		return val;
	}
	skill(){
   		//类中可以使用this去调用类中的方法
  		 console.log(this.name(“yanyue”)+”:”+val);
	}
	add(){
   		return this.a + this.b;
	}
}
```



### 2.类的使用

```js
let yanyue = new Coder;
yanyue.name(“yanyue”);
Coder.cook("肉");
let yanyue = new Coder(1,2);   //类的参数会传递到类中的构造函数中constructor
yanyue.add();
```



### 3.类的继承 -- 继承了父类中的所有函数

```js
class Htmler extends Coder{
}
let YAYO = new Htmler;
YAYO.name(“YAYO”);
```



### 4.super继承父类的属性和方法

```js
class Htmler extends Coder{
say(){
   return super.speak();
	}
}
let YAYO = new Htmler;
YAYO.name(“YAYO”);
```



## 16.模块化的操作export，import

模块化操作

### 1.export 输出，import 引入

> 变量的输出

```js
export const name = “yanyue”;
export const sex = “男”;
export const age =26;
const name = “yanyue”;
const sex = “男”;
const age =26;
export { name,sex,age };
```



> 变量的引入

```js
import { name, sex, age } from “../xxxx”;
```



> 函数的输出和引入

```js
export function add (a,b){
return a+b;
}
import {add} from “./xxx”
```



> 输出变量，使用别名 as

```js
const a = “yanyue”;
const b = “男”;
const c =26;
export {
	a as name,
	b as sex,
	c as age
};
```



> export defalut导出默认的值

```js
export default const name = “yanyue”;
import name from “./xxx”;
```



> import时候使用别名

```js
import * as util from "./xxxx";
```





















































